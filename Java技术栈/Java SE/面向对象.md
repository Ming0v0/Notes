# Java面向对象的三条主线
-   Java的类及类的成员：属性，方法，构造器，代码块，内部类
-   面向对象的三大特征：封装性，继承性，多态性（抽象性）
-   其他关键字：`this, super, static, final, abstract, interface, package, import`等
-  **“大处着眼，小处着手”**

# 什么是面向对象
**“人把大象装进冰箱”**
面向过程：注重事情的每一个步骤及顺序，强调功能的行为，以函数为最小单位，考虑怎么做
1.  把冰箱门打开
2.  抬起大象塞进冰箱
3.  把冰箱门关闭

面向对象：**注重事情有那些参与者（对象）、及各自需要做什么**
```java
人{
	打开（冰箱）{
	冰箱.开开();
}

抬起（大象）{
	大象.进入（冰箱);
}

关闭（冰箱）{
	冰箱.闭合()；
}

冰箱{
	开开（）{}
	闭合（）{}
}

大象{
	进入（冰箱）{}
}
```
从以上例子能看出，面向过程比较直接高效，而面向对象更易于复用、扩展和维护

---

**面向对象的两个要素**
面向对象程序设计的重点是类的设计
设计类，就是设计类的成员
类：对一类事物的描述，是抽象的，概念上的定义
对象：是实际存在的该事物的每个个体，因此也称为实例
**二者的关系，是由类new出来的，派生出来的**

---

**类和对象的使用**
1. 创建类，设计类的成员
2. 创建类的对象
3. 通过`对象.属性`或`对象.方法`调用对象的结构

生活中描述事物无非就是描述事物的属性和行为如：人有身高，体重等属性，有吃饭，睡觉等行为

> 对象是对类的实例化。对象具有状态和行为，属性用来表明对象的状态，方法表明对象所具有的行为。

使用new关键字来创建对象
```java
对象类型 对象名称 = new 类名()；
```

如何调用对象的结构：属性、方法
```java
调用属性："对象.属性";

调用方法："对象.方法";
```

如果创建了一个类的对象，则每个对象都有独立的拥有一套的属性。（非static的）
意味着：如果我们修改一个对象的属性a，则不影响另一个对象属性a的值

---

**类中属性的使用**

成员变量与局部变量对比
**相同点**
1. 定义变量的格式：`数据类型 变量名 = 变量值`
2. 先声明，后使用（强类型）
3. 变量都有其对应的作用域

**不同点**
在类中**声明的位置不同**
- 成员变量：直接定义在类的一个`{ }`内
- 局部变量：声明在方法内，方法形参代码块内，构造器形参，构造器内部的变量

关于**权限修饰符的不同**
- 成员变量：可以声明属性时指明其权限，使用权限修饰符。
- 局部变量：不可以使用权限修饰符

**成员变量与局部变量的默认初始化情况**
成员变量：类的属性，根据其类型，都**有默认初始化值**
- 整型：`byte、 short、int、long = 0`
- 浮点型：`float、double = 0.0`
- 字符型：`char = 0 或 \u0000`
- 布尔型：`boolean = false`
- 引用数据类型：`类，数组，接口 = null`

局部变量：**没有默认初始化值**
意味着：我们在调用局部变量之前，一定要显式赋值
特别地：形参调用时，我们赋值即可。	

在内存中加载的位置
- 成员变量（属性）：加载到堆空间中（非stasic）
- 局部变量：加载到栈空间中

总结：属性赋值的先后顺序
1.  默认初始化
2.  显式初始化/在代码块中赋值
3.  构造器中赋值
4.  有了对象以后，可以通过`对象.方法`或`对象.属性`的方式赋值

---

**类中方法的声明和使用**
方法：**描述类应该具有的功能**

比如：Math类的`sqrt()、random()`等，Scanner类的`next()`等，Array类的`sort()、 binary()等`，String类的`toString()、equals()`等

```java
权限修饰符 返回值类型 方法名（形参列表）{
			方法体
}
```

关于权限修饰符：`public、protected、private、缺省`

返回值对比没有返回值
- 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用return关键字来返回指定类型的变量或常量：`return 数据`
- 如果方法没有返回值，则方法声明中，使用void来表示。通常，没有返回值中，就不使用return，但是如果使用的话，只能`return`表示结束此方法的意思

我们定义方法该不该有返回值
- 题目要求
- 凭经验，具体问题具体分析

方法名：属于标识符，遵循标识符的规则和规范，“见名知意”

参数列表：方法可以声明0个、1个或多个形参
格式：
```txt
（数据类型1 形参1，数据类型2 形参2....）
```

我们定义方法时，该不该定义形参？
1. 题目要求
2. 凭经验，具体问题具体分析

方法体：方法功能的体现

## 封装与隐藏

**问题的引入**

当我们创建一个类的对象以后，我们可以通过：`对象.属性`的方式，对对像的属性进行赋值。
这里，赋值操作要受到属性的数据类型的存储范围的制约。但是除此之外，没有其他制约的条件，但是实际过程中，我们往往给属性赋值加入额外的限制条件，这个限制条件不能在属性声明时体现。
我们只能通过方法进行限制条件的添加。同时我们要避免用户再使用`对象.属性`的方式对属性进行赋值。则需要将属性声明为私有的`private`→此时，针对属性就体现了封装性。

**封装的意义**
**在于明确表示出允许外部使用的所有成员函数和数据项
内部细节对外部调用透明，外部调用无需修改或关心内部实现**

**封装性的体现**
- 体现一：我们将类的属性私有化（private），同时提供公共的（public）方法来读取和设置此属性的值
- 体现二：不对外暴露的私有的方法
- 体现三：单例模式（将构造器私有化）
- 体现四：如果不希望类在包外被调用，可以将类设置为缺省

**封装性的体现，需要权限修饰符来配合**
-   Java规定的4种权限（从小到大排列）：`private、缺省、protected、public`
-   4种权限可以修饰类及类的内部结构：属性，方法，构造器，内部类

Java权限修饰符`public、protected、private`**置于类的成员定义前**，用来限定对象对该类成员的访问权限
| 修饰符    | 类内部 | 同一个包 | 不同包的子类 | 同一个工程 |
| --------- | ------ | -------- | ------------ | ---------- |
| private   |     Yes   |          |              |            |
| (缺省)    |        Yes|          |              |            |
| protected |      Yes  | Yes         |Yes              |            |
| public          |      Yes  |Yes          |    Yes          | Yes           |

对于`class`的权限修饰只可以用`public`和`缺省`
- `public`类可以在任意地方被访问
- 缺省类只可以被同一个包内部的类访问

## 继承
**继承性的好处**
1.  减少了代码的冗余，提高代码的复用性
2.  便于功能的拓展
3.  为之后多态性的使用，提供了前提

**继承的格式**
```java
[访问修饰符] class A extends B {}
```
extends
- A：子类，派生类，subclass
- B：父类，超类，基类，superclass

体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有属性和方法。特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类私有的结构。只有因为封装性的影响，使得子类不能直接调用父类的结构而已。

子类继承父类以后，还可以声明自己特有的属性或方法，实现功能的拓展

子类和父类的关系，不同于子集和集合的关系

**Java中关于继承性的规定**
1.  一个类可以被多个子类继承
2.  Java中的单继承：一个类只有一个父类（一个父亲可以有多个儿子，而儿子只能有一个父亲）
3.  子父类是相对的概念
4.  子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类
5.  子类继承父类以后，就获取了直接父类以及间接父类中声明的属性和方法

**共同的Object父类**
1. 如果我们没有显示的声明一个类的父类的话，则此类继承于`java.lang.Object`类
2. 所有的java类（除java.lang.Object类之外）都直接或间接继承于`java.lang.Object`类
3. 意味着所有的java类具有`java.lang.Object`类声明的功能。

## 多态性
如何理解多态性，可以理解为**一个事物的多种形态。**
对象的多态性：父类的引用指向子类的对象（向上转型）或子类的对象赋给父类的引用 
多态的使用：当调用子父类同名同参数的方法时，实际执行的是子类重写父类的方法 →虚拟方法调用

有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法

总结：**编译看左、运行看右。**
- 多态性的使用前提：① 类的继承关系 ② 方法的重写
- 对象的多态性：只适用于方法，不适用于属性（编译和运行都看左边）

**为什么使用向下转型**
有了对象的多态性以后，内存中实际是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。**子类特有的属性和方法不能调用**

如何才能实现向下转型
使用强制转换符：`()`
```java
父类名 对象a = new 子类名(形参列表);
子类名 对象b = (子类名)对象a;
```

注意点：
1. 使用强转时，可能出现ClassCastException的异常。
2. 使用情景：**为了避免在向下转型时出现ClassCaseExcption的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型**

# 构造器
## 构造器或构造方法的使用
构造器的作用：创建对象
1. 如果没有显式地为类定义构造器的话，则系统**默认提供一个空参的构造器。**
2. 定义构造器的格式：`权限修饰符 类名(形参列表){ }`
3. 一个类定义的多个构造器，彼此构成重载。
4. 一旦我们显式的定义类的构造器之后，系统就不再默认提供一个空参的构造器。
5. 一个类中，至少会有一个构造器。
6. 构造方法的名称必须与类的名称相同。
7. 构造方法不能有返回值，因为没有变量来接收返回值。

# 方法参数的值传递机制
关于变量的赋值
1.  如果变量是基本数据类型，此时赋值的是变量所保存的数据值的副本
2.  如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值

方法的形参的传递机制：
值传递
- 形参：方法定义时，声明的小括号里的参数
- 实参：方法调用时，实际传递给形参的数据

值传递机制：
- 如果参数是基本数据类型，此时实参赋给形参的是实参的数据值的副本
- 如果参数是引用数据类型，此时实参赋给形参的是实参所存储数据的地址值

# 方法的重载
定义：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同、方法返回值和访问修饰符可以不同，发生在编译时。
1. 判断是否重载：跟方法的权限修饰符，返回值类型，形参变量名，方法体无关
2. 在通过对象调用时，如何确定某一个指定的方法：方法名和参数列表
3. 注意点：仅仅返回值类型的不同不足以构成方法的重载

# 方法的重写（override/overwrite）
1. 重写：当子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作
2. 应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法
3. 重写的规定：**两同两小一大原则**
约定俗称：子类中的叫重写的方法，父类中叫被重写的方法
- 两同：
	- 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和**参数列表相同**
	- 父类被重写的方法的返回值类型是**基本数据类型**（比如：double），则子类重写的方法的返回值类型**必须是相同的**
- 两小：
	- 父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型**可以是A类或者A的子类**
	- 子类重写的方法抛出的**异常类型小于等于父类被重写的方法**抛出的异常类型
- 一大：
	- 子类重写的方法的**权限修饰符大于等于父类**被重写的方法的权限修饰符

- 父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型**只能是void**
- 特殊情况子类**不能重写父类中声明为private**权限的方法
- 子类和父类中同名同参数的方法要么声明为非static的（考虑重写），要么都声明为static的（不是重写）。

# 匿名对象的使用
1.  理解：我们创建的对象，没有显示的赋给一个变量名。即为匿名对象
2.  特征：匿名对象只能调用一次

# 可变个数形参的方法
可变个数形参的方法 （JDK5.0新特性）
具体使用：
- 可变个数形参的格式：`(数据类型...变量名)`
- 当调用可变个数形参的方法时，传入的个数可以是0个，1个，2个
- 可变个数形参与本类方法相同，形参不同的方法之间构成重载
- 可变个数形参的方法与本类方法相同，形参类型也相同的数组之间不构成重载，换句话说，二者不能共存
```java
public void show(String...strs){}
public void show(String[] strs){}
```

- 可变个数形参在方法的形参中，必须声明在末尾
```java
public void show(int = i ,String...strs){
	// 方法体
}
```

# 抽象类与抽象方法的使用
## abstract关键字的使用
### abstract修饰类：抽象类
- 此类**不能实例化**。
- 抽象类中一定有构造器，便于子类实例化调用。（涉及：子类对象实例化的全过程）
- 开发中都会提供抽象类的子类，让子类对象实例化，完成相关的操作 
- 抽象类的使用前提：继承性

### abstract修饰方法：抽象方法
-   抽象方法只有方法的声明，没有方法体
-   包含抽象方法的类一定是一个抽象类。反之，抽象类中可以没有抽象方法的。
-   若子类重写了父类中的所有的抽象方法后，此子类方可实例化
-   若子类没有重写了父类中的所有的抽象方法后，则此子类也是一个抽象类，需要abstract修饰

### 注意点：
①：abstract不能用来修饰：属性，构造器等结构
②：abstract不能用来修饰私有方法，静态方法，final的方法，final的类

# 接口的使用
## 接口的定义
1. 接口使用interface来定义
2. Java中，接口和类是并列的两个结构
3. 如何定义接口：定义接口中的成员
	-   JDK7及以前：只能定义全局常量和抽象方法（接口中定义的抽象方法和全局变量都可以通过接口直接去调用），但是书写时，可以省略不写
	-   全局常量：`public static final`
	-   抽象方法：`public abstract`

4. 接口中不能定义构造器！意味着接口不可以实例化
5. Java开发中，通过接口让类去实现（implements）的方式来使用
	① 如果实现类覆盖了接口中的所有的抽象方法，就可以实例化
	② 如果实现类没有覆盖了接口中的所有的抽象方法，则此实现类仍为一个抽象类
	
6. Java类可以实现多个接口弥补了Java单继承的局限性

格式：
```java
class 子类aa extends 父类bb implements 接口CC, 接名DD, 接口EE{
        // ...
}
```

7. 接口与接口之间可以继承，而且可以多继承
8. 接口的具体使用，体现多态性
9. 接口，实际上可以看做是一种规范

## JDK8：新增静态方法、默认方法
在JDK8除了定义全局常量和抽象方法之外，还可以定义静态方法，默认方法
1. 接口中定义的静态方法，只能通过接口来调用
2. 通过实现类的对象，可以调用接口的默认方法，如果实现类重写了接口中的默认方法，调用时则是重写以后的方法
3. 如果子类（或实现类）继承的父类和实现类的接口声明了同名同参数的默认方法。那么在子类没有重写此方法的情况下，默认调用的是父类中的同名同参数的默认方法$\rightarrow$类优先原则
4. 如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没有重写方法的情况下报错。  $\rightarrow$接口冲突
这就需要我们必须在实现类中重写此方法
如何在子类(或实现类)的方法中去调用不同接口同名同参数的默认方法？
通过：接口.super.方法();

## JDK9：新增私有方法
在Interface中编写私有方法时，我们应该遵循以下规则：
-   我们应该使用私有修饰符(private)来定义这些方法。
-   我们不能同时使用私有修饰符（`private`）和`abstract`来定义这些方法。
-   “私有”方法意味着完全实现的方法，因为子类不能继承并覆盖此方法。
-   “抽象”方法意味着无实现方法。这里子类应该继承并覆盖此方法。
-   私有方法必须包含方法体，必须是具体方法。
-   这些接口私有方法仅在该接口内是有用的或可访问的。我们无法从接口访问或继承私有方法到另一个接口或类。

**总结：Java9为我们提供的新功能——在接口中定义私有方法，对我们有很大的帮助，这将减少重复代码，提高代码的重用性，同时将私有方法写在接口中，不让子类看到，有很好的安全性。

## 接口和抽象类的区别
-   抽象类可以存在普通成员函数，而接口中只能存在public abstract方法，Java8新增默认方法和静态方法，Java9新增私有方法
-   抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的
-   抽象类只能继承一个、接口可以实现多个

接口的设计目的，是对类的行为进行约束（更准确的说是“有”一种约束，因为接口不能规定类不可以有什么行为），也就是提供一种机制，可以强制要求不同类具有相同的行为，它只约束了行为的有无，但不对任何实现行为进行限制。

而抽象类的设计目的，是代码复用。当不同的类具有某些相同的行为（记为集合A），且其中一部分行为的实现方法一致时（A的非真子集，记为B），可以让这些类都派生于一个抽象类。在这个抽象类实现了B，避免让所有的子类来实现B，这就达到了代码复用的目的。而A减B的部分，留给各个子类自己实现。证书因为A-B在这里没有实现，所以抽象类不允许实例化出来（否则当调用A-B时，无法执行）。

抽象类是对类本质的抽象，表达是is a的关系，比如BMW is  a car。抽象类包含并实现子类的通用特性，将子类存在差异化的特性进行抽象，交由子类去实现。

而接口是对行为的抽象，表达的是like a的关系，比如 Bird like a Aircraft(像飞行器一样可以飞)，但其本质上is a Bird。接口的核心是定义行为，即实现类可以做什么，至于实现类主体是谁，是如何实现的，接口并不关心

使用场景：当你关注一个事务的本质的时候，用抽象类；当你关注一个操作的时候，用接口

抽象类的功能要远超过接口，但是，定义抽象类的代价高。因为高级语言来说（从实际设计上来说也是）每个类只能继承一个类。在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它，只是针对一个动作的描述，而且你可以在一个类中同时实现多个接口。在设计阶段会降低难度。

# 内部类
1. Java中允许将一个类A声明在另一个类B中，则类A就是内部类，B类称为外部类
2. 内部类的分类：成员内部类（静态，非静态）vs 局部内部类（方法内，代码内，构造器内）
3. 成员内部类：
一方面，作为外部类的成员
-   调用外部类的结构
-   可以被static修饰
-   可以被4种不同的权限修饰

另一方面，作为一个类
-   类可以定义属性，方法，构造器等
-   可以被final修饰，表明此类不能被继承
-   可以被abstract修饰

4. 如何实例化成员内部类的对象
静态的成员内部类：外部类.内部类 对象=new 外部类.内部类()；
非静态的成员内部类，先实例化外部类，再进行内部化实例

5.如何在成员内部类中区分调用外部类的结构
调用外部类的结构：类名.this.属性/方法();

# 包装类
## 为什么要有包装类（或封装类）?
为了使基本数据类型的变量具有类的特征，引入包装类。

## 基本数据类型与对应的包装类：
| 基本数据类型 | 包装类  |
| ------------ | ------- |
| byte         | Byte    |
| short        | short   |
| int          | lnteger |
| long         | Long    |
| float        | Float   |
| double       | Double  |
| boolean      | Boolean |
| char             |     Character    |
需要掌握的类型间的数据类型
![[attachment/Pasted image 20220612193700.png]]
简易版：
基本数据类型$\leftrightarrow$包装类类型：自动拆箱，自动装箱
基本数据类型、包装类型$\leftrightarrow$String类:调用String重载的valueof(Xxx xxx）
String类$\leftrightarrow$基本数据类型，包装类型:调用包装类的parseXxx(String）
注意：转换时，可能会报NumberFormatException异常

# Object类
java.lang.Object类
1. Object类是所有Java类的根父类
2. 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类
3. Object类中的功能（属性，方法）就具有通用性
属性：无
方法：`equals()、toString()、getClass()、hashCode()、clone()、finalize()、wait()、notify()、notifyAll()`
4. Object类只声明了一个空参的构造器

# 代码块
代码块（或初始化块）：`{ }`
## 代码块的作用：
用来初始化类（静态），对象（非静态）

## 代码块的分类
代码块如果有修饰的话，只能使用static
### 静态代码块
- 内部可以有输出语句
- **随着类的加载而执行，而且只执行一次**
- 作用：初始化类的信息
- 如果一个类的中定义了多个静态的代码块，则按声明的先后顺序执行
- 静态代码块的执行要**优先于非静态的代码块的执行**
- 静态代码块内只能调用静态的属性，静态的方法，不能调用非静态的结构

### 非静态代码块
- 内部可以有输出语句
- **随着对象的创建而执行**
- 每创建一个对象，就执行一个非静态代码块
- 作用：可以在创建对象时，对对象的属性进行初始化
- 如果一个类中定义呢多个非静态代码块，则按声明的先后顺序执行
- 非静态代码块内可以调用静态的属性，静态的方法，或非静态的属性，非静态的方法

实例化子类对象时，设计到父类，子类中静态的代码块，非静态代码块，构造器
-   由父及子，静态先行

# this关键字
1.  this可以用来修饰，调用：属性，方法，构造器
2.  this修饰属性和方法

## this作用
理解为：当前对象 或 当前正在创建的对象
- 在类的方法中，我们可以使用`this.属性`或`this.方法`的方式，**调用当前对象属性或方法**。但是通常情况下，我们都选择省略`this`.。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用`this.变量`的方式，表明此变量是类属性，而非形参。
- 在类的构造器中，我们可以使用`this.属性`或`this.方法`的方式，调用当前创建的对象属性或方法。但是通常情况下，我们都选择省略`this`.。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用`this.变量`的方式，表明此变量是属性，而非形参。

## this调用构造器
-  我们在类的构造器中，可以显式的使用`this(形参列表)`方式，调用本类中指定的其他构造器
-  构造器中不能通过`this(形参列表)`调用自己，不能形成闭环
-  如果一个类中有n个构造器，则最多有在`n – 0`构造器中使用了`this(形参列表)`
-  规定：`this(形参列表)`必须声明在构造器的首行
-  构造器内部，最多只能声明一个`this(形参列表)`，用来调用其他的构造器
-  不能再构造器以外的任何方法内调用构造方法

# return关键字
return关键字的使用
使用范围：使用在方法体中
作用：
- 结束方法，类似break
- 针对有返回值类型的方法，使用`return 数据`方法返回所要的数据
注意点：return关键字后面不可以声明执行语句

# final关键字
## final的作用
final可以用来修饰的结构：`类，方法，变量`

### final修饰类
此类不能被其他类所继承。比如：`String类，System类，StringBuffer类`

### final修饰方法
表明此方法不可以被子类重写，但是可以重载。比如：`Object类中getClass()`

### final修饰变量
此时的`变量`就称为是一个常量，就不可以改变的它的值
- final修饰属性：可以考虑赋值的位置有：`显式初始化，代码块中初始化，构造器中初始化`
- final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。但当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后就只能在方法体内使用此形参，但不能重新赋值
- final修饰成员变量：在声明的时候就需要赋值，或者静态代码块赋值
- 修饰基本类型数据和引用类型数据
	- 如果是基本数据类型的变量，则其数值一旦初始化之后便不能更改
	- 如果是引用类型的变量，则在其初始化之后便不能在让其指向另一个对象。但是引用的值是可变的

# native 关键字
native 关键的理解
使用 native 关键字说明这个方法是原生函数，也就是这个方法是用 C/C++等非 Java 语言实现的，并且被编译成了 DLL，由 java 去调用。
1. 为什么要用 native 方法 java 使用起来非常方便，然而有些层次的任务用 java 实现起来不容易，或者我们对程序的效率很在意时，问题就来了。例如：有时 java 应用需要与 java 外面的环境交互。这是本地方法存在的主要原因，你可以想想 java 需要与一些底层系 统如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制： 它为我们提供了一个非常简洁的接口，而且我们无需去了解 java 应用之外的繁琐的细节。
2. native 声明的方法，对于调用者，可以当做和其他 Java 方法一样使用 一个 native method 方法可以返回任何 java 类型，包括非基本类型，而且同样可以进行异常控制。
native method 的存在并不会对其他类调用这些本地方法产生任何影响，实际上 调用这些方法的其他类甚至不知道它所调用的是一个本地方法。JVM 将控制调用本地方法的所有细节。
如果一个含有本地方法的类被继承，子类会继承这个本地方法并且可以用 java 语言重写这个方法（如果需要的话）

# static关键字的使用
## static的作用
static可以用来修饰：属性，方法，代码块，内部类

## static的分类
### 静态属性
使用static修饰属性：按是否使用static修饰，又分为：静态属性 vs 非静态属性（实例变量）

-   实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。**当修改其中一个对象的非静态属性时，不会导致其他对象同样的属性值的修改**
-   静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。**当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量是修改过的。**

static修饰属性的其他说明：
- 静态变量随着类的加载而加载。可以通过`类.静态变量`的方式进行调用
- 静态变量的加载要早于对象的创建
- 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。
- Java中静态变量只能在类主体中定义，不能在方法中定义。 静态变量属于类所有而不属于方法。
- 因为类加载时间早于对象实例创建时间，所以可以通过`类名.静态变量`，不能`类名.实例变量`

### 静态方法
使用static修饰方法：静态方法（类方法）
- 随着类的加载而加载。可以通过`类名.静态方法`的方式进行调用
- 静态方法中，只能调用静态的方法或属性
- 非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性

## static注意点
- 在静态的方法内，不能使用`this`关键字，`super`关键字
- 关于静态属性和静态方法的使用，从生命周期的角度去理解

1. 开发中如何确定一个属性是否要声明`static`的？
-   属性是可以被多个对象所共享的，不会随着对象的不同而不同
-   类中的常量也常常声明为`static`

2. 如何确定一个方法是否要声明`static`的？
-   操作静态属性的方法，通常设置为`static`的
-   工具类中的方法，习惯上声明为`static`的，比如`Math，Arrays，Collections`

# package关键字
1.  为了更好的实现项目中类的管理，提供包的概念
2.  使用package声明类或接口所属的包，声明在源文件的首行
3.  包，属于标识符，遵循标识符的命名规则，规范包名小写，“见名知意”
4.  每`.`,就代表一层文件目录
补充：同一个包下，不能命名同名的接口，类。
不同的包下，可以命名同名的接口，类。

# import关键字
1.  在源文件中显式的使用import结构导入指定包下的类，接口
2.  声明在包的声明和类之间
3.  如果需要导入多个结构，则并列写即可
4.  可以使用`xxx.*`的方式，表示可以导入xxx包下的所有结构
5.  如果使用的类或接口是java.lang包下定义的，则可以省略import结构
6.  如果使用的类或接口是本包下定义的，则可以省略import结结构
7.  如果源文件中，使用不同包名下的同名的类，则必须至少有一个需要以全类名的方式显示。
8.  使用“`xxx.*`”方式表面可以调用xxx包下的所有结构，但是如果使用的是xxx子包下的结构，则仍需要显式导入
9.  `Import static`：导入指定类或接口中静态的结构：属性或方法

# super关键字
super可以用来调用：属性，方法，构造器
## super的使用
- 我们可以在子类的方法或构造器中。通过使用`super.属性`或`super.方法`的方式，显式的调用父类中声明的属性或方法。但是通常情况下，我们习惯省略`super`
- 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中的属性，则必须显式的使用`super.属性`的方式，表明调用的是父类中声明的属性。
-   特殊情况：当子类重写父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式使用`super.方法`的方式，表明调用的是父类被重写的方法

## super调用构造器
-   我们可以在子类的构造器中显式的使用`super(形参列表)`的方式，调用父类中声明的指定的构造器
-   `super(形参列表)`的使用，必须声明在子类构造器的首行
-   我们在类的构造器中，没有显式的声明`this(形参列表)`”或`super(形参列表)`，则默认构造器调用的是父类中空参的构造器
-   在类的多个构造器中，至少有一个类的构造器使用了`super(形参列表)`，调用父类中的构造器

## 子类对象实例化的全过程：
1. 从结果上来看：（继承性）
子类继承父类以后，就获取了父类中声明的属性或方法
创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。

2. 从过程上来看：
当我们通过子类的构造器创建对象时，我们一定会直接或者间接的调用其父类的构造器，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所有才可以看到内存中有父类的结构，子类对象才可以考虑进行调用。

明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象

# instanceof关键字
1.  `a instanceof  A`：判断对象a是否为类A的实例。如果是，返回true;如果不是，返回false。
2. 如果`a  instanceof  A`返回`true`，而`a  instanceof  B`也返回`true`。其中，类B是类A的父类
3. 要求a所属的类与类A必须是子类和父类的关系，否则编译错误。

图示：![[attachment/Pasted image 20220612200533.png]]

# equals()方法
## 回顾 == 的使用
使用在基本数据类型变量和引用数据类型变量中
- 如果比较的是基本数据类型变量，则比较两个变量保存的数据是否相等。
 - 如果比较的是引用数据类型变量，则比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体。
补充：用“\==”进行比较时，符号两边的数据类型必须兼容(可自动转换的基本数据类型除外)，否则编译出错 

## equals()方法的使用
1. 是一个方法，而非运算符
2. 只能适用于引用数据类型
3. Object类中`equals()`的定义
```java
public boolean equals(Object obj){
	return （this == obj）
}
```
说明：Object类中定义的`equals()`和`==`的作用是相同的：比较两个对象二点地址值是否相同。即两个引用是否指向同一对象实体。

4. 像`String、Date、File、包装类`等都重写了Object类中的`equals()`方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同。
5. 通常情况下，我们自定义的类如果使用`equals()`的话，也通常是比较两个对象的“实体内容”是否相同。那么，我们就需要对Object类中的`equals()`进行重写。

重写的原则：比较两个对象的实体内容是否相同。

重写equals()方法的原则
- 对称性：`如果x.equals(y)返回是“true” ，那么y.equals(x)也应该返回是 “true”。`
- 自反性：`x.equals(x)必须返回是“true”。`
- 传递性：`如果x.equals(y)返回是“true” ，而且y.equals(z)返回是“true” ， 那么z.equals(x)也应该返回是“true”。`
- 一致性：`如果x.equals(y)返回是“true” ，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。`
- 任何情况下，`x.equals(null)`，永远返回是“false” ； `x.equals(和x不同类型的对象)`永远返回是“false”。

面试题：`==`和`equals()`的区别
- `==` 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址
- equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是`==`;我们可以看到String等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之，形成了equals是比较值的错误观点。
- 具体要看自定义类里有没有重写Object的equals方法来判断。
- 通常情况下，重写equals方法，会比较类中的相应属性是否都相等。

# toString()方法
Object类中toString()的使用：
1. 当我们输出一个对象的引用时，实际上就是调用当前对象的toString()方法
```java
System.out.println (对象名a);
System.out.println (对象名a.toString());
```
2. Object类中toString()的定义：
```java
public String toString(){
    return getClass().getName.()+”@”+Integer.toHexSting(hashCode()):
}
```
3. 像String、Date、File,包装类等都重写了Object类中的toString()的方法。使得在调用对象的toString()时，返回“实体内容”信息
4. 自定义类也可以重写toString()方法，当调用此方法时，返回对象的“实体内容”