# 什么是程序、进程、线程
## 程序
程序（program）是为完成特定任务，用某种语言编写的一组指令的集合。即一段静态的代码，静态对象
## 进程 
进程（process）是程序的一次执行过程，或是正在运行的一个程序有它自身的产生、存在和消亡的过程。 
进程的生命周期
- 程序是静态的，进程是动态的
- 进程作为资源分配的单位，系统在运行是会为每个进程分配不同的内存区域
## 线程
线程（thread）：进程进一步细化为线程，是一个程序内部的一条执行路径
- 若一个进程同一时间并行执行多个线程，就是支持多线程
- 线程作为调度和执行的单位，每个线程拥有自己独立的运行栈和程序计数器（pc），多个线程共享同一个进程的方法区和堆，线程切换的开销小
- 一个进程中的多个线程共享的内存单元/内存地址空间 它们从一堆中分配对象，可以访问相同的变量和对象，这就使得线程间通信更简便，高效。但多个线程操作共享的系统资源可能就会带来安全的隐患
图示：
![[attachment/Pasted image 20220612203225.png]]

## 单核 CPU 和多核 CPU 的理解
1. 单核 CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱， 那么收费人员可以把他“挂起”（晾着他，等他想通了，准备好了钱，再去收费)。但是因为 CPU 时间单元特别短，因此感觉不出来。
2. 如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）
3. 一个 Java 应用程序 java.exe ，其实至少有三个线程：main()主线程、垃圾回收线程gc()、异常处理线程。当然如果发生异常，会影响主线程 。

## 并行和并发的理解
并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事情
并发：一个CPU（采用时间片）同时执行多个任务。比如：秒杀，多个人做同一个事情

## 多线程程序的优点：
1.  提高应用程序的响应。对图形化界面更有意义，可增强用户体验。
2.  提高计算机系统 CPU 的利用率
3.  改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改

# 多线程的创建方式
## 方式一：继承于Thread类
1.  创建一个继承于`Thread`类的子类
2.  重写Thread类的`run()`方法,将此线程执行的操作声明在`run()`方法中
3.  在主线程`main`中，创建`Thread`类的子类的对象
4.  通过此对象调用Thread类的s`tart()`方法：① 启用当前线程 ② 调用当前`run()`方法

技巧① 可以创建Thread类的匿名子类的方式：
```java
new Thread(){
	@Override
	public void run(){
	// 方法体
	}
}.start();
```
说明两个问题：
问题一：我们启动一个线程，必须调用`start()`，不能调用`run()`的方式启动线程
问题二：如果在启动一个线程，必须重新创建一个子类的对象，调用此对象的`start()`

## 方式二：实现Runnable接口
1.  创建一个实现了`Runnable`接口的类
2.  实现类去实现Runnable中的抽象方法：`run()`
3.  在主线程main中，创建实现类的对象
4.  将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
5.  通过Thread类的对象调用start()方法

两种创建方式的对比：

开发中：优先选择：实现Runnable接口的方式
原因：
1. 实现的方法没有类的单继承的局限性
2. 实现的方式更适合来处理多个线程有共享数据的情况

联系：`public class Thread implements Runnable`
Thread类也同样实现接口Runnable

相同点:
1.  两种方式都要重写run()，将线程要执行的逻辑声明在run()中。
2.  目前两种方式，要想启动线程，都是调用Thread类中的start()

## Thread类的有关方法：
- void start()：启动线程，并执行对象的run()方法
- run()：线程在被调度时执行的操作
- String getName()：返回当前线程的名字
- void setName(String name)：设置当前线程的名字
- static Thread currentThread()：返回当前线程。在Thread子类中就是this，通常用于主线和runnable实现类
- static void yield()：线程让步
	-   暂停当前正在执行的线程，把执行的机会让给优先级相同或者更高的线程,
	-   若队列中没有同优先级的线程，忽略此方法
- join()：当某个程序执行流中调用其他线程的join()方法时，调用线程将被阻塞，直到join()方法加入join线程执行完为止(类似插队)
	- 低优先级的线程也可以获得执行
- static void sleep(long millis)：(指定时间:毫秒）
	- 令当前活动线程在指定时间段内放弃对CPU控制，使其他线程有机会被执行，时间到后重排队
	- 抛出InterrupteException异常
-   stop()：强制线程生命期结束，不推荐使用
-   boolean isAlive()：返回boolean，判断线程是否还存活

## 方式三：实现Callable接口
1. 创建一个实现Callable的实现类
2. 实现call方法，将此线程需要执行的操作声明在call()中
3. 创建Callable接口实现类的对象
4. 将此Callable接口实现类的对象作为传递到Future构造器中，创建FutureTask的对象
5. 将FutureTask的对象作为产生传递到Thread类的构造器中，创建Thread对象，并调用start()方法
6. 获取Callable中方法的返回值

说明：
如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？
1. call()可以有返回值
2. 可以捕获异常，被外面的操作捕获，获取异常的信息
3.  Callable是支持泛型的

## 方式四：使用线程池
1. 提供指定线程数量的线程池
 设置线程池的属性
2. 执行指定的线程的操作，需要提供实现Runnble接口或Callable接口类的对象
关闭连接池

好处：
1.  提高相应速度（减少创建新线程的时间）
2.  降低资源消耗（重复利用线程池中线程，不需要每次都创建）
3.  便于线程管理
corePoolSize：核心池的大小
maximumPoolSize：最大线程数
keepAliveTime：线程没有任务四最大保持多长时间后终止

面试题：创建多线程有几种方式？四种

# 线程的优先级
Java 的调度方法
-   同优先级线程组成先进先出队列（先到先服务），使用时间片策略
-   对高优先级，使用优先调度的抢占式策略

线程的优先级等级
- MAX_PRIORITY:10
- MIN_ PRIORITY:1
- NORM_ PRIORITY:5(默认优先级)

如何获取和设置当前线程的优先级
- getPriority():获取线程的优先级
- setPriorty(int newPriority)：改变线程的优先级

说明：
- 线程创建时继承父线程的优先级
-  高优先级的线程要抢占低优先级线程CPU的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。比不意味着只有高优先级的线程执行完后，低优先级的线程才执行。

# 线程的安全
# Java解决方案：同步机制
例子：创建个窗口卖票，总票数为100张，使用实现Runnable接口的方式
1. 问题：卖票过程中，出现了重票，错票。出现了线程的安全问题
2. 问题出现的原因：当某个线程操作的过程中，尚未操作完成时，其他线程参与进来操作车票
3. 如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，也不能被改变

## 方式一：同步代码块
```java
synchronized(同步监视器){
	// 需要被同步的代码
}
```
说明：
1. 操作共享数据的代码，即需要被同步的代码。不能包含代码多了，也不能包含代码少了
2. 共享数据：多个线程共同操作的变量。
3. 同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。
要求：多个线程必须要共同同一把锁。

线程同步利弊：
好处：同步的方式解决了线程的安全问题
局限性：操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。

补充：
1.  在实现Runnable接口创建多线程的方式中，我们可以考虑this充当同步监视器
2.  在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器

## 方式二：同步方法
如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。
关于同步方法的总结
1.同步方法仍涉及到同步监视器，只是不需要我们显式的声明。
2.非静态的同步方法，同步监视器是：this(当前对象)
  静态的同步方法，同步监视器是：当前类本身
  
 ## 方式三：lock锁
```java
class Window3 implements Runnable {

private int ticket = 100;

private ReentrantLock lock = new ReentrantLock();

@Override
public void run() {
        while (true) {
            try {
                //2.调用锁定方法：lock()
                lock.lock();
                if (ticket > 0) {
                    System.out.println(Thread.currentThread().getName() + ":卖票，票号为" + ticket);
                    ticket--;
                } else {
                    break;
                }
            }
            finally {
                //调用解锁方法：ulock()
                lock.unlock();
           }
        }
      }
    }
```

 1. 面试题：synchronized与lock锁的异同
- 相同：二者都可以解决线程安全问题
- 不同：synchronized机制在执行完相应的同步代码以后，自动释放同步监视器
            lock需要手动的启动同步(lock()),同时结束同步也需要手动的实现（ulock())
            
2. 优先使用顺序：
lock->同步代码块（已经进入了方法体，分配了相应资源）->同步方法（在方法体之外）

线程的死锁问题：
死锁的理解：
不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要同步的资源，就形成了线程的死锁
说明：
1.  出现死锁以后，就不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续
2.  我们使用同步时，要避免死锁。