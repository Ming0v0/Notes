# 动态规划算法介绍

1. 动态规划(**Dynamic Programming**)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法

2. 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。

3. 与分治法不同的是，**适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。** ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )

4. 动态规划可以通过**填表的方式**来逐步推进，得到最优解.



# 应用场景-背包问题

背包问题：有一个背包，容量为4磅 ， 现有如下物品

| 物品    | 重量 | 价格 |
| ------- | ---- | ---- |
| 吉他(G) | 1    | 1500 |
| 音响(S) | 4    | 3000 |
| 电脑(L) | 3    | 2000 |

1. 要求达到的目标为装入的背包的总价值最大，并且重量不超出4榜
2. 要求装入的物品不能重复
3. 思路分析和图解
（1）背包问题主要是指一个给定容量的背包、若干具有一定价值和重量的物品，如何选择物品放入背包使物品的价值最大。其中又分01背包和完全背包(完全背包指的是：每种物品都有无限件可用) 
（2）这里的问题属于01背包，即每个物品最多放一个。而无限背包可以转化为01背包。
（3）算法的主要思想，利用动态规划来解决。每次遍历到的第i个物品，根据w\[i]和v\[i]来确定是否需要将该物品放入背包中。即对于给定的n个物品，设`v[i]`、`w[i]`分别为第i个物品的价值和重量，C为背包的容量。再令`v[i][j]`表示在前i个物品中能够装入容量为j的背包中的最大价值。则我们有下面的结果。
（4）解决类似的问题可以分解成一个个的小问题进行解决，假设存在背包容量大小分为1，2，3，4的各种容量的背包(分配容量的规则为最小重量的整数倍)


   | 物品 | 0 磅 | 1磅  | 2磅  | 3磅  | 4磅  |
   | -------- | ------------ | ---- | ---- | ---- | ---- |
   |          | 0            | 0    | 0    | 0    | 0    |
   | 吉他(G)  | 0            |      |      |      |      |
   | 音响(S)  | 0            |      |      |      |      |
   | 电脑(L)  | 0            |      |      |      |      |

  ` v[i][0] = v[0][j]=0`
➡️表示 填入表 第一行和第一列是0 

   对于第一行(`i=1`), 目前只有吉他可以选择，所以

   | 物品 | 0磅 | 1磅     | 2磅     | 3磅     | 4磅     |
   | -------- | ------------ | ------- | ------- | ------- | ------- |
   |          | 0            | 0       | 0       | 0       | 0       |
   | 吉他(G)  | 0            | 1500(G) | 1500(G) | 1500(G) | 1500(G) |
   | 音响(S)  | 0            |         |         |         |         |
   | 电脑(L)  | 0            |         |         |         |         |

   对于第二行(`i=2`),目前存在吉他和音响可以选择,所以

   | 物品 | 0磅 | 1磅     | 2磅     | 3磅     | 4磅     |
   | -------- | ------------ | ------- | ------- | ------- | ------- |
   |          | 0            | 0       | 0       | 0       | 0       |
   | 吉他(G)  | 0            | 1500(G) | 1500(G) | 1500(G) | 1500(G) |
   | 音响(S)  | 0            | 1500(G) | 1500(G) | 1500(G) | 3000(S) |
   | 电脑(L)  |              |         |         |         |         |

   对于第三行(`i=3`),目前存在吉他和音响、电脑可以选择,所以

   | 物品 | 0磅 | 1磅     | 2磅     | 3磅     | 4磅       |
   | -------- | ------------ | ------- | ------- | ------- | --------- |
   |          | 0            | 0       | 0       | 0       | 0         |
   | 吉他(G)  | 0            | 1500(G) | 1500(G) | 1500(G) | 1500(G)   |
   | 音响(S)  | 0            | 1500(G) | 1500(G) | 1500(G) | 3000(S)   |
   | 电脑(L)  | 0            | 1500(G) | 1500(G) | 2000(L) | 3500(L+G) |

  ` w[i] `和`j` 之间的关系 推导

   **案例一**：`v[1][1]` = ?     
   `w[1]= 1`  
   `j = 1`

   使用公式：`v[i][j] = max{v[i-1][j],v[i-1][j-w[i]]+v[i]}` 
= `v[1][1]`
= `max{v[0][0], v[0][0]+v[1]} `
= `max{0, 0 + 1500}`

   **案例二**：v\[3\][4] = ? i = 3 j = 4 w\[3\] = 3 

   j >= w\[3\]

   使用公式：

   v\[i\]\[j\]=max{v\[i-1\]\[j\],v\[i-1\]\[j-w\[i\]\]+v\[i\]} = v\[3\]\[4\] = max{v\[2\]\[4\], v\[2\]\[1\]+v\[3\]} = max{3000, 1500 + 2000} = max{3000, 3500} = 3500

   

# 完整代码

```java
package dynamic;

import java.nio.file.Path;
import java.util.Arrays;

public class KnapsackProblem {

    public static void main(String[] args) {
        int[] w = {1, 4, 3};            // 物品的重量
        int[] val = {1500, 3000, 2000}; // 物品的价值
        int m = 4;                      // 背包的容量
        int n = val.length;             // 物品的个数

        // 创建二维数组
        // v[i][j] 表示在前 i 个物品能够装入容量为 j 的背包的最大价值
        int[][] v = new int[n + 1][m + 1];

        int[][] path = new int[n + 1][m + 1];

        // 初始化第一行和第二列，这里在本程序中，可以不去处理，因为默认就是 0
        for (int i = 0; i < v.length; i++) {
            v[i][0] = 0; // 将第一列设置为 0
        }
        for (int i = 0; i < v[0].length; i++) {
            v[0][i] = 0;// 将第一行设置为 0
        }

        // 根据前面的公式来动态规划
        //  i: 表示第i个商品
        //  j: 表示背包的容量
        for (int i = 1; i < v.length; i++) {
            for (int j = 1; j < v[0].length; j++) {
                // 公式
                // 判断当前商品的重量是否大于背包的容量
                if (w[i - 1] > j) { // 因为我们程序 i 是从 1 开始的，因此原来的公式中的 w[i] 修改成 w[i-1]
                    v[i][j] = v[i - 1][j];
                } else {
                    // 说明：
                    // v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);
                    // v[i][j] =Math.max(上一个单元格的值, 当前商品的价值+剩余空间的最大价值)
                    // 例如：i = 3,j = 4
                    // v[3 - 1][4], val[3 - 1] + v[4 - 1][4 - w[3 - 1]] == v[2][4]+ val[2] + v[2][1] == 1500 ,2000+1500
                    // 这里 体现了即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解

                    // 个人理解:
                    // v[i - 1][j - w[i - 1]] 有剩余容量的情况下, 在上一阶段寻找最优的装入策略

                    // 为了记录商品存放到背包的情况，我们不能直接的使用上面的公式，需要使用if-else 来体现公式
                    if (v[i - 1][j] < val[i - 1] + v[i - 1][j - w[i - 1]]) {
                        v[i][j] = val[i - 1] + v[i - 1][j - w[i - 1]];
                        // 把当前的情况记录到path
                        path[i][j] = 1;
                        // 这里，path是用来记录，当增加一种可放入物品的时候，当前最大价值是否包含新加进来的物品
                        // 如果包含，就在path里标记一个1，path和之前的统计表格的大小是一模一样的
                    } else {
                        v[i][j] = v[i - 1][j];  // 表示上一个单元格的值
                    }
                }
            }
        }
        // 输出遍历
        for (int[] arr : v) {
            System.out.println(Arrays.toString(arr));
        }

        // 而此时这个比把定位放到了单元格最后一格，也就是我们想去求的，包容量=4和三个种类都可以往里加的情况
        int i = path.length - 1;
        int j = path[0].length - 1;
        while (i > 0 && j > 0) {
            if (path[i][j] == 1) {// 这时候如果该格的path是1，则说明最后那种商品是在里面的（这里是电脑），除了电脑包容量只剩 4-电脑，可以放的东西只有前面那两个了
                System.out.printf("第%d个商品放入到背包\n", i);
                // 就去看看对应包容量和只能放吉他和音响的时候，对应的path格是不是1
                j -= w[i - 1];// 剩余背包的容量 = 当前背包容量 -当前物品的重量
            }
            i--;
        }
    }
}
```

