# FCFS 调度(先来先服务)

磁盘调度的最简单形式当然是先来先服务（FCFS）算法。虽然这种算法比较公平，但是它通常并不提供最快的服务。

按照请求到达的顺序来处理磁盘上的I/O请求。具体来说，**当有多个I/O请求等待被处理时，FCFS会选择最早到达的请求进行执行。** 这意味着磁盘将按照请求的顺序进行访问，不考虑请求的位置或者寻道时间。

例如，考虑一个磁盘队列，其 I/O 请求块的柱面的顺序如下：  
**`98,183,37,122,14,124,65,67`**

如果磁头开始位于柱面 53，那么它首先从 `53` 移到 `98`，接着再到 `183`、`37`、`122`、`14`、`124`、`65`，最后到 `67`，磁头移动柱面的总数为 `640`。

这种调度如图所示。  
![](attachment/Pasted%20image%2020231026091623.png)
从 `122` 到 `14` 再到 `124` 的**大摆动说明了这种调度的问题**。如果对柱面 `37` 和 `14` 的请求一起处理，不管是在 `122` 和 `124` 之前或之后，总的磁头移动会大大减少，并且性能也会因此得以改善。

先来先服务（FCFS）算法的主要特点和优缺点

**特点**
- **简单性：** FCFS是最简单的磁盘调度算法，易于实现和理解。
- **公平性：** 由于按照请求到达的顺序处理，每个请求都有机会被满足，保持了公平性。

**缺点**
- **寻道时间不可控：** FCFS不考虑请求的位置，可能导致磁头在磁盘上不断移动，造成较长的平均寻道时间。这种随机性的磁头移动可能降低了性能。
- **不适合高吞吐量：** 对于需要高吞吐量和低延迟的应用来说，FCFS通常不是一个理想的选择，因为它不能最小化磁头移动。
- **不考虑请求的重要性：** FCFS对所有请求都一视同仁，不考虑请求的紧急性或重要性。这可能导致对一些重要请求的长时间等待。

>磁盘寻道时间（Disk Seek Time）是指在硬盘上读取或写入数据时，磁头从当前位置移动到磁盘上另一个指定位置所需的时间。这个时间包括以下几个主要组成部分
>
   **寻道时间（Seek Time）：** 寻道时间是磁头从当前磁道位置移动到目标磁道位置的时间。这个时间包括了磁头的加速和减速，以及寻道过程中的电机驱动时间。寻道时间通常是磁盘I/O操作中最耗时的部分。
>
   **旋转延迟（Rotational Latency）：** 旋转延迟是指等待目标数据块旋转到磁头下方的时间。硬盘的盘片会以一定的速度旋转，所以磁头需要等待合适的扇区旋转到它的位置上。旋转延迟的平均时间是半个磁盘旋转周期。
>
   **传输时间（Transfer Time）：** 传输时间是指从磁盘读取或写入数据的实际时间，通常是相对较短的时间，与寻道时间和旋转延迟相比，可以忽略不计。
>   
   总的磁盘I/O时间可以用以下公式表示：
   `Total I/O Time = Seek Time + Rotational Latency + Transfer Time`
>   
   减少寻道时间对于提高磁盘性能非常重要，因为寻道时间通常是磁盘访问操作的瓶颈之一。因此，磁盘调度算法的设计旨在最小化寻道时间，以提高数据访问效率。各种不同的磁盘调度算法都旨在通过优化寻道顺序来减少磁头移动，从而降低总的I/O时间。

# SSTF调度(最短寻道时间优先)

在移动磁头到别处以便处理其他请求之前，处理靠近当前磁头位置的所有请求可能较为合理。这个假设是最短寻道时间优先（SSTF）算法的基础。

SSTF 算法选择处理距离当前磁头位置的最短寻道时间的请求。换句话说，SSTF 选择最接近磁头位置的待处理请求。

对于上面请求队列的示例，与开始磁头位置 `53` 的最近请求位于柱面 `65`。一旦位于柱面 `65`，下个最近请求位于柱面 `67`。从那里，由于柱面 `37` 比 `98` 还要近，所以下次处理 `37`。如此，会处理位于柱面 `14` 的请求，接着 `98`，`122`，`124`，最后`183`。  
![](attachment/Pasted%20image%2020231026094909.png)

这种调度算法的磁头移动只有 `236` 个柱面，约为 FCFS 调度算法的磁头移动总数的三分之一多一点。显然，这种算法大大提高了性能。

SSTF 调度本质上是一种最短作业优先（SJF）调度；与 SJF 调度一样，它可能会导致一些请求的饥饿。请记住，请求可能随时到达。假设在队列中有两个请求，分别针对柱面 `14` 和 `186`，而当处理来自 `14` 的请求时，另一个靠近 `14` 的请求来了，这个新的请求会下次处理，这样位于 `186` 的请求需要等待。当处理该请求时，另一个 `14` 附近的请求可能到达。

理论上，相互接近的一些请求会连续不断地到达，这样位于 186 上的请求可能永远得不到服务。当等待处理请求队列较长时，这种情况就很可能出现了。

虽然 SSTF 算法比 FCFS 算法有了相当改进，但是并非最优的。对于这个例子，还可以做得更好：移动磁头从 `53` 到 `37`（虽然 37 并不是最近的），再到 14，再到 `65`、`67`、`98`、`122`、`124`、`183`。这种策略的磁头移动的柱面总数为 `208`。

**优点**
- **最小化寻道时间：** SSTF算法的主要优点是它能够最小化寻道时间。通过选择最接近磁头位置的请求，可以减少磁头的移动，从而降低了I/O操作的响应时间。
- **高性能：** 由于SSTF优化了磁头的移动，它通常能够提供较高的性能，特别是在磁盘负载较重的情况下。

**缺点**
- **饥饿问题：** SSTF算法可能导致一些请求长时间等待，特别是当有周期性或持续的大量请求到达时。这是因为总是选择最近的请求可能会导致某些请求永远得不到满足。
- **不适用于高吞吐量：** 对于需要高吞吐量的应用，SSTF可能不是最佳选择，因为它侧重于最小化寻道时间，而不考虑其他性能因素。


# SCAN 调度(电梯算法)

对于扫描算法，磁臂从磁盘的一端开始，向另一端移动；在移过每个柱面时，处理请求。当到达磁盘的另一端时，磁头移动方向反转，并继续处理。磁头连续来回扫描磁盘。SCAN 算法有时称为电梯算法，因为磁头的行为就像大楼里面的电梯，先处理所有向上的请求，然后再处理相反方向的请求。

**工作原理**

- 电梯算法维护一个请求队列，队列中的请求按照它们在磁盘上的磁道位置排序。
- 初始时，电梯算法设置一个初始方向，通常是向磁道号增加的方向（向上）。然后，它开始执行请求队列中的请求。
- 算法选择最接近当前磁头位置且在当前运动方向上的请求来执行。如果队列中没有这样的请求，电梯会改变运动方向，并选择最接近的请求继续执行
- 磁头会按照当前方向执行请求，直到队列中没有更多请求。一旦队列为空，算法就会停止。
- 如果在执行过程中有新的请求到达，它们会根据它们的磁道位置被插入到队列中的适当位置。

下面回到前面的例子来说明。在采用 SCAN 来调度柱面 `98`、`183`、`37`、`122`、`14`、`124`、`65` 和 `67` 的请求之前，除了磁头的当前位置，还需知道磁头的移动方向。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200408181128552.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjEyOTMw,size_16,color_FFFFFF,t_70)

假设磁头朝 0 移动并且磁头初始位置还是 `53`，磁头接下来处理 `37`，然后 `14`。在柱面 0 时，磁头会反转，移向磁盘的另一端，并处理柱面 `65`、`67`、`98`、`122`、`124`、`183`上的请求。如果请求刚好在磁头前方加入队列，则它几乎马上就会得到服务；如果请求刚好在磁头后方加入队列，则它必须等待，直到磁头移到磁盘的另一端，反转方向，并返回。


**优点**
1. **相对平衡的性能：** 电梯算法通常能够提供相对平衡的性能，不会像FCFS那样容易导致请求饥饿问题。
2. **较小的平均寻道时间：** 电梯算法考虑了请求的相对位置，能够减少寻道时间，并在大多数情况下提供较高的性能。

**缺点**
1. **不适用于某些特殊情况：** 对于特定的请求分布模式，电梯算法可能不是最佳选择，因为它的性能依赖于请求的相对位置。
2. **可能引入等待延迟：** 当磁头需要反向移动时，电梯算法可能引入额外的等待时间，因为它会在反向寻找请求。这可能会影响某些应用的性能。

假设请求柱面的分布是均匀的，考虑当磁头移到磁盘一端并且反转方向时的请求密度。这时，紧靠磁头前方的请求相对较少，因为最近处理过这些柱面。磁盘另一端的请求密度却是最多。这些请求的等待时间也最长，那么为什么不先去那里？这就是下一个算法的想法。

# C-SCAN 调度(循环扫描)

CSCAN调度算法是在扫描算法的基础上改进的，为了减少延迟，规定磁头单向移动，例如，只是自里向外移动，从当前位置开始沿磁头的移动方向去选择离当前磁头最近的那个柱面访问，如果沿磁头的方向无请求时，磁头立即返回到最里面的欲访问的柱面，再亦即将最小柱面号紧接着最大柱面号构成循环。

下面回到前面的例子来说明。在采用 SCAN 来调度柱面 98、183、37、122、14、124、65 和 67 的请求之前，除了磁头的当前位置，还需知道磁头的移动方向。

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020040818161071.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjEyOTMw,size_16,color_FFFFFF,t_70)  
C-SCAN 调度算法基本上将这些柱面作为一个环链，将最后柱面连到首个柱面。

# LOOK 调度

正如以上所述，SCAN 和 C-SCAN 在磁盘的整个宽度内移动磁臂。实际上，这两种算法通常都不是按这种方式实施的。更常见的是，磁臂只需移到一个方向的最远请求为止。

遵循这种模式的 SCAN 算法和 C-SCAN 算法分别称为 LOOK 和 C-LOOK 调度，因为它们在向特定方向移动时查看是否会有请求（图 5）。  
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200408181748251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjEyOTMw,size_16,color_FFFFFF,t_70)  