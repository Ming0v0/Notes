# 进程管理概念
进程管理也称为处理机管理，其核心是如何合理地分配处理机的时间，提高系统的效率。在计算机系统中有多个并发执行的程序，采用“程序”这个静态的概念已经不能描述程序执行时动态变化的过程，所有引入了“进程”。

**基本概念**
主要任务：完成处理机资源的分配调度，处理机调度的单位可为进程或线程。
-   进程控制
-   进程同步与互斥
-   进程通信
-   进程调度

# 进程组成
进程是动态的概念。进程通常由程序，数据和进程块PCB组成。
- 程序。作用：描述进程要完成的功能。
- 数据。作用：程序在执行时所需要的数据和工作区。
- PCB。作用：包含进程的描述信息和控制信息。**它是进程存在的唯一标志。** 进程控制块

# 进程的状态及其状态间的切换
进程在执行过程中，由于操作系统中出现的不同事件导致进程执行的间歇性、不确定性，使进程的状态也随执行过程发生变化。有五种状态：
![[attachment/Pasted image 20220522141605.png]]
- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

# 进程控制
进程控制是**指对系统中所有进程从创建到消亡的全过程实施有效的控制**在操作系统中通过设置一套控制机构对进程实施控制，其主要功能包括创建一个新进程，撤销一个已经运行完的进程，改变进程的状态，实现进程间的通信。**进程控制是由操作系统内核中的原语实现的。**
    原语是若干条机器指令组成的、用于完成特定功能的程序段。原语的特点是在**执行时不能被分割**，即原子操作要么都做，要么都不做。内核中所包含的原语主要有进程控制原语、进程通信原语、资源管理原语以及其他原语。属于进程控制方面的原语有进程创建原语、进程撤销原语、进程激活原语、进程阻塞原语以及进程唤醒原语等。不同的操作系统，内核所包含的功能不同，但大多数操作系统的内核都包含支撑功能和资源管理的功能。

# 进程通信
## 进程通信-同步和互斥概念
操作系统引入进程后，由于进程的异步性，可能会导致程序执行结果的不确定性，使程序执行时出现不可再现性。
    进程互斥与同步的主要任务是使并发执行的诸进程之间能有效地共享资源和相互合作，从而使程序的执行具有可再现性。
- 同步：指多个进程中发生的事件存在着某种时序关系，它们必须按规定时序执行，以共同完成一项任务。
- 互斥：多个进程不能同时使用同一资源。
- 临界资源：某段时间内仅允许一个进程使用的资源。
- 临界区：每个进程中访问临界资源的那段代码。

**异步性**是指进程以不可预知的速度向前推进。<font color='#ce003b'>内存中的每个进程何时执行,何时暂停,以怎样的速度向前推进,每道程序总共需要多少时间才能完成等,都是不可预知的（不确定性）。</font>

是程序并发执行时，程序之间的相互制约关系导致了并发程序这种“执行——暂停——执行”这种间断性的活动规律。

比如，当正在执行的进程提出某种资源请求时，如打印请求，而此时打印机正在为其他某进程打印，由于打印机属于临界资源，因此正在执行的进程必须等待，且放弃处理机，直到打印机空闲，并再次把处理机分配给该进程时，该进程方能继续执行。可见，由于资源等因素的限制，进程的执行通常都不是“一气呵成”，而是以“停停走走”的方式运行。

<font color='#ce003b'>异步性就是描述进程这种以不可预知的速度走走停停、何时开始何时暂停何时结束不可预知的性质。</font>

也就是说，如果传统意义上的程序没有在操作系统中为之配备进程控制块（PCB），没有用它来描述进程基本情况和活动过程，进而控制和管理进程，这样就会使程序在并发执行的时候失去其封闭性，也失去了可再现性。

但是，如果操作系统采用了进程同步机制，虽然程序具有异步性（走走停停、以不可预知的速度前进），但仍能保证进程并发执行的结果是可再现的。

所以，只要在操作系统中配置有完善的进程同步机制，且运行环境相同，作业经多次运行都会获得完全相同的结果。因此，异步运行方式是允许的。

## 进程通信-信号量机制
**信号量机制**：即利用PV操作来对信号量进行处理。
**信号量**：一个特殊的变量，用于进程间传递信息的整数值，信号量的值与相应资源的使用情况有关。
**信号量S**：
- 当它的值S>=0时，表示当前可用资源的数量
- 当它的值S<0时，其绝对值表示阻塞队列等待使用该资源的进程个数
注意：信号量的值仅能由PV操作来改变以及初始化。

   <font color='#ce003b'>P操作和V操作都是不可分割的原子动作，也称为原语。</font>
P操作表示申请一个资源、V操作表示释放一个资源

**P(S)**：执行一次P操作意味着请求分配一个单位资源
    因此S=S-1；当S<0时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。

**V(S)**：而执行一个V操作意味着释放一个单位资源
    因此S=S+1；若S<=0，表示释放S信号量队列上的一个等待进程，使之进入就绪队列。

当S > 0时，表示还有资源可以分配
当S < 0时，其绝对值表示信号量等待队列中进程的个数
每执行一次P操作，意味着要求分配一个资源，每执行一次V操作，意味着释放一个资源

## 进程通信-信号量机制实现进程互斥
令信号量mutex的初值为1，进入临界区时执行p操作，退出临界区时执行V操作。这样，进入临界区的代码如下：
    P（mutex）
        临界区
    V  (mutex)

## 进程通信-信号量机制实现进程同步
### 单缓冲区的同步控制
【例】生产者进程2不断地生产产品送入缓冲区，消费者进程P2不断地从缓冲区中取
产品消费。请给出实现进程同步的模型图。
解：为了实现P1与P2，进程间的同步问题，需要设置两个信号量S1和 S2，但信号量初值
不同可有如下两种实现方案。
方案1：信号量S1的初值为1，表示缓冲区空，可以将产品送入缓冲区；信号量S2的初值
为0，表示缓冲区有产品。
其同步过程如图所示。
![[attachment/Pasted image 20220522143320.png]]
方案2：信号量S1的初值为0，信号量S2的初值为0，此时同步过程如图所示。
![[attachment/Pasted image 20220522143349.png]]

### n个缓冲区的同步控制
【例】一个生产者和一个消费者，缓冲区中可存放n件产品，生产者不断地生产产品，消费者不断地消费产品，如何用PV操作实现生产者和消费者的同步。可以通过设置3个信号量S、S1和S2，其中，S是一个互斥信号量，初值为1，因为缓冲区是一个互斥资源，所以需要进行互斥控制；S1表示是否可以将产品放入缓冲区，初值为n；S2表示缓冲区是否存有产品，初值为0。其同步过程如图所示。
![[attachment/Pasted image 20220522143558.png]]
![](C:\Users\Jun\OneDrive\我的文档\笔记\计算机基础\操作系统\images\n个缓冲区的同步控制.png)

## 进程通信-进程调度算法
 进程调度：解决以何种次序对各就绪进程进行处理机（CPU）的分配以及按何种时间比例让进程占用处理机（CPU）。
**进程调度的方式通常有可剥夺和非剥夺方式两种。**
- 所谓可剥夺方式，是指<font color='#5b9bde'>就绪队列中一旦有优先级高于当前运行进程的优先级的进程存在时，便立即发生进程调度，转让处理机。</font>
- 非剥夺方式则是指<font color='#5b9bde'>即使在就绪队列中存在有优先级高于当前运行进程的进程，当前进程仍将继续占有处理机，直到该进程完成或某种事件发生（如 I/O 事件）让出处理机。</font>
	因为“可剥夺”优先级调度始终保证在处理机上运行的是优先级最高的进程，这样，当处理机正在运行某个进程时，很可能会被其他优先级更高的进程“抢占”引起处理机调度，和“非剥夺”算法相比，前者的调度次数会更频繁，而每调度一次都会引起保护现场、恢复现场的工作，所以“可剥夺”的优先级调度算法开销更大。

### 进程调度常用算法如下：
 1. 先来先服务调度算法（FIFO）
   这种调度算法是<font color='#ce003b'>按照进程进入就绪队列的先后次序选择可以占用处理器的进程。</font>当有进程就绪时，把该进程排入就绪队列的末尾，而进程调度总是把处理器分配给就绪队列中的第一个进程。一旦一个进程占有了处理器，它就一直运行下去，直到因等待某事件或进程完成了工作才让出处理器。

2. 优先数调度算法（HPF）
   <font color='#ce003b'>对每个进程确定一个优先数，进程调度总是让具有最高优先数的进程先使用处理器。</font>如果进程具有相同的优先数，则对这些有相同优先数的进程再按先来先服务的次序分配处理器。就绪队列中进程可按优先数从大到小排列，这样，进程调度也总是把处理器分配给就绪队列中的第一个进程。进程被创建时系统为其确定一个优先数，进程的优先数可以是固定的，也可随进程的执行过程而动态变化。优先数调度算法分为“非抢占式”的与“可抢占式”的两种。

3. 时间片轮转调度算法（RR)
   <font color='#ce003b'>系统规定一个“时间片”的值。调度算法让就绪进程按就绪的先后次序排成队列，每次总是选择就绪队列中的第一个进程占用处理器，但规定只能使用一个“时间片”。</font>如果一个时间片用完，进程工作尚未结束，则它也必须让出处理器而被重新排到就绪队列的末尾，等待再次运行，当再次轮到运行时，重新开始使用一个新的时间片。这样，就绪队列中的进程就依次轮流地占用处理器运行。
    轮转法主要是用于分时系统的调度算法，它具有较好的响应时间，且对每个进程来说都具有较好的公平性。

先来先服务调度算法是“非抢占式”的；“优先数调度算法”可以是“非抢占式”的，也可以是“抢占式”的；“时间片轮转调度算法”是一种“抢占式”的。

# 进程通信-死锁
在多道程序系统中，虽可通过多个进程的并发执行来改善系统的资源利用率和提高系统的处理能力，但可能发生一种危险——死锁。<font color='#ce003b'>死锁是多个进程因竞争资源而造成的一种僵局</font>，若无外力作用，这些进程都将永远不能再向前推进。
   我们可以把死锁定义为：**若系统中存在一组进程（两个或多个进程），它们中的每一个进程都占用了某种资源而又都在等待其中另一进程所占用的资源，这种等待永远不能结束，则说系统出现了“死锁”，或说这组进程处于“死锁”状态。**

> 哲学家们共用一张圆桌，围绕着圆桌而坐，在圆桌上有五个碗和五支筷子，平时哲学家进行思考，饥饿时拿起其左、右的两支筷子，试图进餐，进餐完毕又进行思考。

这里的问题是哲学家只有拿到靠近他的两支筷子才能进餐，而拿到两支筷子的条件是他的左、右邻居此时都没有进餐。

## 死锁具有以下特点：
1. 陷入死锁的进程是系统并发进程中的一部分，且**至少要有两个进程**，单个进程不会形成死锁。
2. 陷入死锁的进程彼此都在**等待对方释放资源**，形成一个循环等待链。
3. 死锁形成后，在没有外力干预下，陷入死锁的进程不能自己解除死锁，死锁进程**无法正常结束**。
4. 如不及时解除死锁，死锁进程占有的资源不能被其他进程所使用，导致系统中更多进程阻塞，造成**资源利用率下降**。

## 系统产生死锁必定同时保持以下四个必要条件：
1. **互斥条件**：进程应互斥使用资源，任一时刻一个资源仅为一个进程独占，若另一个进程请求一个已被占用的资源时，它被置成等待状态，直到占用者释放资源。
2. **占有且等待条件**：一个进程请求资源得不到满足而等待时，不释放已占有的资源。
3. **不剥夺条件**：任一进程不能从另一进程那里抢夺资源，即已被占用的资源，只能由占用进程自己来释放。
4. **循环等待条件**：存在一个循环等待链，其中，每一个进程分别等待另一个进程所持有的资源，造成永远等待。
这四个条件仅是必要条件而不是充分条件，即只要发生死锁则这四个条件一定会同时成立，但反之则不然。

## 解决死锁的方法
1. **预防死锁**。预防死锁是在系统运行之前就采取相应措施，<font color='ce003b'>消除发生死锁的任何可能性。消除死锁发生的必要条件可预防死锁。</font>破坏产生死锁的四个必要条件中一个或几个来预防产生死锁。预防死锁是处理死锁的静态策略，它虽比较保守、资源利用率低，但因简单明了较易实现，现仍被广泛使用。
2. **避免死锁**。避免死锁是为了克服预防死锁的不足而提出的动态策略。避免死锁与预防死锁的策略不同，它并不是事先采取各种限制措施，去破坏产生死锁的四个必要条件，而是<font color='ce003b'>在资源动态分配过程中，用某种方法防止系统进入不安全状态（根据资源的使用情况**提前做出预测**），从而可以避免发生死锁。</font>避免死锁方法虽好，但也存在两个缺点：一是对每个进程申请资源分析计算较为复杂且系统开销较大；二是在进程执行前，很难精确掌握每个进程所需的最大资源数。["银行家算法"](https://blog.csdn.net/qq_33414271/article/details/80245715)
3. **检测死锁**。这种方法无须事先采取任何限制性措施，允许进程在运行过程中发生死锁。但可通过检测机构及时地检测出死锁的发生，然后采取适当的措施，把进程从死锁中解脱出来。死锁检测不延长进程初始化时间，允许对死锁进行现场处理，其缺点是通过剥夺解除死锁，给系统或用户造成一定的损失。
4. **解除死锁**。当检测到系统中已发生死锁时，就采取相应措施，**将进程从死锁状态中解脱出来**。常用的方法是撤销一些进程，回收它们的资源，将它们分配给已处于阻塞状态的进程，使其能继续运行。在实际执行中，由于并发进程推进顺序的多样性，系统很难做到有效地解除死锁。

# 线程的概念
进程是程序的一次执行过程和资源分配的基本单位。
## 引入线程的目的
为了更好地实现并发处理和共享资源，提高CPU的利用率，提高系统的执行效率，减少处理机的空转时间和调度切换的时间，减少内存开销，便于系统管理。
