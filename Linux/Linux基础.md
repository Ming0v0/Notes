# 概述

Linux 是一款操作系统，免费，开源， 安全，高效，稳定， 处理高并发非常强悍，现在很多的企业级的项目都部署到 Linux/unix 服务器运行。

## Unix 是怎么来的

Unix的起源可以追溯到1960年代末和1970年代初的贝尔实验室（Bell Labs），当时由肯·汤普逊（Ken Thompson）、邓恩·懋耀（Dennis Ritchie）和布莱恩·克尼汉（Brian Kernighan）等人共同开发。当时，他们正致力于开发一个方便且高效的操作系统，以支持贝尔实验室的研究工作。

最初，他们开发了一个名为Multics（Multiplexed Information and Computing Service）的多用户、多任务操作系统。然而，由于Multics在实际应用中存在一些问题，并且成本昂贵，因此贝尔实验室最终决定退出Multics项目。

于是，肯·汤普逊和丹尼斯·里奇继续他们的工作，尝试以更简单和高效的方式重新构建一个操作系统。他们使用汇编语言和C语言编写了一些系统工具和库，并基于这些工具和库构建了一个新的操作系统，他们将其命名为Unix。

Unix最初是在PDP-7上开发的，后来也移植到了其他硬件平台上。它的**开源**特性使得Unix逐渐受到其他机构的关注和采用，包括其他大学、政府机构和企业。

**Unix提供了许多创新的概念和功能，如单一根目录树、管道、Shell脚本、标准输入输出和多用户支持等。** 这些概念和功能对后来的操作系统设计和发展产生了深远的影响。

后来，许多公司和组织基于Unix开发了自己的操作系统，如IBM的AIX、HP的HP-UX和Sun的Solaris等。此外，由于Unix的开源性质，许多类Unix操作系统也诞生，如Linux和FreeBSD等。

总的来说，Unix是由肯·汤普逊和丹尼斯·里奇等人在贝尔实验室开发的一个操作系统，他们的工作为后来操作系统设计和发展奠定了基础。

## Linux和Unix的关系

Linux 和 Unix 有密切的关联和关系。

Linux 是一个开源的操作系统内核。它最初是由芬兰的程序员 Linus Torvalds 在 1991 年创建的，后来得到了全球开发者的贡献和支持。Linux 内核是 Linux 操作系统的核心部分，它负责管理计算机硬件和软件资源。然而，单独的 Linux 内核并不足以构建一个完整的操作系统。

Unix 是一个类 Unix 操作系统家族的总称，是 1969 年由贝尔实验室研发的。它被设计为一个多用户、多任务的操作系统，具有稳定性和安全性。Unix 操作系统在学术界和商业界都有广泛应用，并且被其他操作系统广泛借鉴和模仿。

Linux 在其设计上受到了 Unix 的启发，并借鉴了 Unix 的一些核心概念和设计原则，如文件系统层次结构、权限管理、进程管理等。因此，Linux 和 Unix 之间存在许多相似之处，菜单划的命令也基本一致，大部分Unix操作中经典的命令在Linux下也有。这使得 Unix 系统的用户很容易转换到 Linux 系统中。

此外，由于 Unix 操作系统对代码的开放性，使得 Linux 操作系统中的代码也可以被重新编写，进一步推动了 Linux 和 Unix 的发展和交流。

因此，尽管 Linux 是一个独立的操作系统，但它和 Unix 有密切的关联和关系。

## Linux和Windows比较

Linux和Windows是两种不同的操作系统，它们在很多方面有所不同。

1. 开源性：Linux是开源操作系统，用户可以自由地查看、修改和分发其源码。而Windows是闭源的，无法查看和修改其源码。

2. 可定制性：由于开源性，Linux允许用户根据自己的需求对系统进行自定义和调整。用户可以选择不同的Linux发行版，并根据需要添加或删除软件包。Windows的定制性相对较低。

3. 安全性：由于Linux的开放性和开源性，其安全性相对较高。许多安全专家和网络管理员认为Linux比Windows更安全，不容易受到恶意软件的攻击。Windows则因其市场份额较大，成为攻击者攻击的主要目标。

4. 文件系统：Linux使用了一种称为“ext”的文件系统，而Windows使用了NTFS或FAT文件系统。这些文件系统具有一些不同的特性和优缺点。

5. 软件支持：由于Windows在桌面和商业市场上的占有率较大，它拥有更多的软件和游戏支持，包括大多数商业和专有软件。Linux的软件支持相对较少，但已经有越来越多的开源和免费软件开发者支持Linux平台。

6. 用户界面：Windows有传统的图形用户界面（GUI），比较容易上手。Linux则提供多种不同的用户界面选择，包括传统的桌面环境（如GNOME和KDE）以及更轻量级的界面（如Xfce和LXDE）。

7. 成本：Linux是自由和开源的操作系统，用户可以免费下载、安装和使用。而Windows是商业软件，用户需要购买许可证才能合法地使用。

总的来说，Linux和Windows各有其优势和适用场景。Linux适合技术人员和开发者，提供了更好的可定制性和安全性；Windows适合普通用户和商业用户，提供了更多的软件和游戏支持。选择哪个操作系统取决于用户的需求和个人偏好。

# Linux 的目录结构

linux 的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录`/`，然后在此目录下再创建其他的目录。
![](attachment/Pasted%20image%2020230913001427.png)

  
记住一句经典的话：**在 Linux 世界里，一切皆文件**

## 目录结构的具体介绍

`/bin` (/user/bin、/user//local/bin)
- 是Binary的缩写，这个目录存放着最经常使用的命令

`/sbin` (/usr/sbin、/user/local/sbin)
- s是指Super User的意思，这里存放的是系统管理员使用的系统管理程序

`/home`
- 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的

`/root`
- 该目录为系统管理员，也称作超级权限者的用户主目录

`/boot`
- 存放的是启动Linux时使用的一些核心文件，包括一些连接文件及镜像文件

`/proc`
- 这个目录是一个虚拟的目录，他是系统内存的映射，访问这个目录来获取系统信息

`/srv`
- service缩写，该目录存放一些服务启动之后需要提取的数据

`/sys`
- 这是Linux2.6内核的一个很大的变化，该目录下安装了2.6内核中新出现的一些文件系统

`/tmp`
- 这个目录是用来存放一些临时文件的

`/dev`
- 类似于WIndows的设备管理器，把所有的硬件用文件的形式存储

`/medie`
- Linux系统会自动设别一些设备，例如U盘、光驱等等，当识别后，Linux会把识别的设备挂载到这个目录下

`/mnt`
- 系统提供该目录是为了让用户临时挂载别的文件系统，我们将外部的存储挂载在`/mnt`上。然后进入该目录就可以查看里面的内容

`/opt`
- 这是给主机额外安装软件所摆放的目录。如安装Oracle数据库就可以放到该目录下。默认为空

`/usr/local`
- 这是另一个给主机额外安装软件的安装目录，一般是通过编译源码方式的程序

`/var`
- 这个目录中存放着不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件

`/selinux` `security-enhanced linux`
- SElinux是一种安全子系统，它能控制程序只能访问特定文件。

**总结**

- Linux 的目录中有且只要一个根目录` /`
- Linux 的各个目录存放的内容是规划好，不用乱放文件。
- Linux 是以文件的形式管理我们的设备，因此 Linux 系统，一切皆为文件。

# Vi 和 Vim 编辑器

## 基本介绍

所有的 Linux 系统都会**内建 Vi 文本编辑器。**

Vim 具有程序编辑的能力，可以看做是 **Vi 的增强版本** ，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。

## Vi 和 Vim 的三种常见模式

**正常模式**
在正常模式下，我们可以使用快捷键。

以 vim 打开一个档案就直接进入正常模式了(这是默认的模式)。在这个模式中， 可以使用『上下左右』按键来移动光标，可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用『复制、贴上』来处理你的文件数据。

**插入模式/编辑模式**
在插入模式下，程序员可以输入内容。

按下` i, I, o, O, a, A, r, R` 等任何一个字母之后才会进入编辑模式,  一般来说按 i 即可

**命令行模式**
在这个模式当中， 可以提供你相关指令，完成读取、存盘、替换、离开 vim 、显示行号等的动作则是在此模式中达成的

**Vi 和 Vim 三种模式的相互转化图**
![](attachment/Pasted%20image%2020230912110247.png)
## 快捷键的使用案例

拷贝当前行   `yy`
- 正常模式下拷贝当前行向下的 5 行  `5yy`，并粘贴`p`。

删除当前行  `dd`。 
- 正常模式下删除当前行向下的 5 行 `5dd`

在文件中查找某个单词。
- 命令行模式下 `/关键字` 回车查找 ，输入 n 就是查找下一个

设置文件的行号，取消文件的行号。
- 命令行下：`set nu` 和 `set nonu`

撤销操作
- 在一个文件中输入 `hello` ，然后又撤销这个动作，再回到正常模式下输入 `u`

快速定位
- 编辑 `/etc/profile` 文件，使用快捷键到底文档的最末行`G`和最首行`gg`，注意这些都是在正常模式下执行的。
- 编辑  `/etc/profile` 文件，并将光标移动到 第 20 行 `shift+g`
- 第一步：显示行号 `:set nu`，第二步：输入 20 这个数，第三步: 输入 `shift+g`

**Vim 和 Vi 的快捷键键盘一览图**
![](attachment/Pasted%20image%2020230912114101.png)

# 开机、重启和用户登录注销

## 关机&重启命令

**shutdown**
```txt
shutdown [选项] [时间]
```

参数
- shutdown -h now : 表示立即关机
- shutdown -h 1 : 表示 1 分钟后关机
- shutdown -r now:  立即重启

**halt**
就是直接使用，效果等价于关机

**reboot**
重启系统。

**syn**
把内存的数据同步到磁盘

**注意细节**
当我们关机或者重启时，都应该先执行以下 sync 指令，把内存的数据写入磁盘，防止数据丢失。

## 用户登录和注销

登录时尽量少用 root 帐号登录，因为它是系统管理员，最大的权限，避免操作失误。可以利用普通用户登录，登录后再用`su 用户名`命令来切换成系统管理员身份.

在提示符下输入 `logout` 即可注销用户

**使用细节**

- logout 注销指令在图形运行级别无效，在 运行级别 3 下有效

# 用户管理

![](attachment/Pasted%20image%2020230912114921.png)
说明
- Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。
- Linux 的用户需要至少要属于一个组。

## 添加用户

**基本语法**
```txt
useradd  [选项] 用户名
```

**演示**
添加一个用户 xm
![](attachment/Pasted%20image%2020230912115342.png)

特别说明：
cd    表示 change directory, 切换目录.

**细节说明**
- 当创建用户成功后，会自动的创建和用户同名的家目录
- 也可以通过 `useradd -d 指定目录 新的用户名`，给新创建的用户指定家目录
![](attachment/Pasted%20image%2020230912115455.png)

## 给用户指定或者修改密码

**基本语法**
```
passwd 用户名
```

**演示**
给 xiaoming 指定密码
![](attachment/Pasted%20image%2020230912115643.png)

## 删除用户

**基本语法**
```
userdel  用户名
```

**演示**
删除用户 xm，但是要保留家目录
![](attachment/Pasted%20image%2020230913002839.png)

删除用户 xh 以及用户主目录
![](attachment/Pasted%20image%2020230913002845.png)

**细节**
在删除用户时，我们一般不会将家目录删除。

## 查询用户信息

**基本语法**
```
id  用户名
```

  
**演示**
案例 1：请查询 root 信息
![](attachment/Pasted%20image%2020230912121758.png)

**细节说明**
当用户不存在时，返回”无此用户”

## 切换用户

**介绍**
在操作 Linux 中，如果当前用户的权限不够，可以通过 su  指令，切换到高权限用户，比如 root

**基本语法**
```
su 切换用户名
```

**演示**
创建一个用户 zf, ，指定密码，然后切换到 zf.
![](attachment/Pasted%20image%2020230912121326.png)

**细节说明**
- 从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。
- 当需要返回到原来用户时，使用 exit 指令

## 用户组

**介绍**
类似于角色，系统可以对有共性的多个用户进行统一的管理。

**增加组**
```
groupadd 组名
```

**案例演示**
![](attachment/Pasted%20image%2020230912121721.png)

---
  
**删除组**
```
groupdel 组名
```

案例演示
![](attachment/Pasted%20image%2020230912121732.png)

## 配置文件

**/etc/passwd 文件**
用户（user）的配置文件，记录用户的各种信息
每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell
![](attachment/Pasted%20image%2020230912121933.png)

**/etc/shadow 文件**
口令的配置文件
每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志

**/etc/group 文件**
![](attachment/Pasted%20image%2020230912122116.png)
组(group)的配置文件，记录 Linux 包含的组的信息
每行含义：组名:口令:组标识号:组内用户列表

# 实用指令

## 指定运行级别

运行级别说明

- 0：关机
- 1：单用户【找回丢失密码】
- 2：多用户状态没有网络服务
- 3：多用户状态有网络服务
- 4：系统未使用保留给用户
- 5：图形界面
- 6：系统重启

常用运行级别是 3 和 5 ，要修改默认的运行级别可改文件

`/etc/inittab 的 id:5:initdefault`:这一行中的数字

运行级别的示意图
![](attachment/Pasted%20image%2020230912122345.png)


### 切换到指定运行级别的指令
**基本语法**
```txt
init [012356]
```

![](attachment/Pasted%20image%2020230912122636.png)

案例 1： 通过 init 来切换不同的运行级别，比如动 5->3 ， 然后关机
```txt
init    3
init    5
init    0
```

如何找回 root 密码，如果我们不小心忘记 root  密码，怎么找回。

思路： 进入到 单用户模式，然后修改 root 密码。因为进入单用户模式，root 不需要密码就可以登录。

**总结**
开机->在引导时输入 回车键-> 看到一个界面输入 e -> 看到一个新的界面，选中第二行（编辑内核）在输入 e->  在这行最后输入 1 ,再输入 回车键->再次输入 b ,这时就会进入到单用户模式。

这时，我们就进入到单用户模式，使用 passwd  指令来修改 root  密码。

## 帮助指令
当我们对某个指令不熟悉时，我们可以使用 Linux 提供的帮助指令来了解这个指令的使用方法。

**man 获得帮助信息**

**基本语法**

```txt
man [命令或配置文件]（功能描述：获得帮助信息）
```

**演示**
案例：查看 ls 命令的帮助信息
![](attachment/Pasted%20image%2020230913003518.png)

---

**help 指令**

```txt
help 命令 （功能描述：获得 shell 内置命令的帮助信息）
```

**演示**

案例：查看 cd 命令的帮助信息
![](attachment/Pasted%20image%2020230913003604.png)

  

## 文件目录类
---
**pwd 指令**

基本语法
```txt
pwd (功能描述：显示当前工作目录的绝对路径)
```

**演示**
案例：显示当前工作目录的绝对路径
![](attachment/Pasted%20image%2020230913003633.png)

  

---
**ls指令**

基本语法
```txt
ls   [选项]  [目录或是文件]
```

常用选项
- -a ：显示当前目录所有的文件和目录，包括隐藏的。
- -l    ：以列表的方式显示信息

**演示**
案例:查看当前目录的所有内容信息
![](attachment/Pasted%20image%2020230912161800.png)

  
![](attachment/Pasted%20image%2020230912161807.png)

---
**cd 指令**

基本语法
```txt
cd    [参数] (功能描述：切换到指定目录)
```

常用参数
- 绝对路径和相对路径

> **如何理解绝对路径和相对路径**
> 绝对路径是指**从文件系统的根目录开始指定文件或目录的位置**，它包含了完整的路径信息。例如，在Windows系统中，绝对路径可能是`C:\Users\myuser\Documents\file.txt`，在Unix/Linux系统中，绝对路径可能是`/home/myuser/Documents/file.txt`。无论当前所在的工作目录是什么，绝对路径都可以准确地定位到文件或目录。
> 
> 相对路径是相对于当前目录或当前文件位置的路径。它**指定的是文件或目录与当前位置的相对关系**。相对路径可以简化路径的输入。例如，当前目录下的文件file.txt的相对路径可能是`./file.txt`或者`file.txt`，其中"."表示当前目录。父目录中的文件的相对路径可能是`../file.txt`，其中".."表示父目录。
> 
> **总结起来，绝对路径是从根目录开始指定文件或目录的路径，相对路径是相对于当前位置指定文件或目录的路径。**

- `cd ~` 回到自己的家目录

- `cd ..` 回到当前目录的上一级目录

**演示**
案例 1：使用绝对路径切换到 root 目录
```txt
cd  /root
```

案例 2：使用相对路径到/root 目录
这里我们需要知道该用户目录在哪个目录下，才能写出这个指令，假设在`/usr/lib 
```txt
cd   ../../root
```

案例 3：表示回到当前目录的上一级目录
```txt
cd ..
```

案例 4：回到家目录cd
```txt
cd ~
```

---

**mkdir 指令**

mkdir 指令用于创建目录(make directory)

基本语法
```txt
mkdir [选项]  要创建的目录
```
  
常用选项
- -p ：创建多级目录

**演示**
案例 1：创建一个目录 `/home/dog`
![](attachment/Pasted%20image%2020230912162720.png)

案例 2：创建多级目录 /home/animal/tiger
![](attachment/Pasted%20image%2020230912162752.png)

--- 
**rmdir 指令**

rmdir 指令删除空目录

基本语法
```txt
rmdir [选项]  要删除的空目录
```

**演示**
案例 1：删除一个目录 /home/dog
![](attachment/Pasted%20image%2020230912162911.png)

**使用细节**
`rmdir` 删除的是空目录，如果目录下有内容时无法删除的。
提示：如果需要删除非空目录，需要使用  `rm -rf` 要删除的目录

![](attachment/Pasted%20image%2020230912162959.png)

---
touch 指令

touch 指令创建空文件

基本语法
```txt
touch 文件名称
```

演示
案例 1：创建一个空文件 hello.txt
![](attachment/Pasted%20image%2020230912163113.png)

![](attachment/Pasted%20image%2020230912163119.png)

--- 
**cp 指令**

cp 指令拷贝文件到指定目录

基本语法
```txt
cp [选项] source dest
```

常用选项
- -r ：递归复制整个文件夹

演示
案例 1：将 `/home/aaa.txt`  拷贝到` /home/bbb` 目录下(拷贝单个文件)
![](attachment/Pasted%20image%2020230912163313.png)

案例 2：递归复制整个文件夹，举例
将/home/test 整个目录拷贝到 /home/zwj 目录
![](attachment/Pasted%20image%2020230912163330.png)


**使用细节**

强制覆盖不提示的方法：`\cp`

![](attachment/Pasted%20image%2020230912163514.png)

---

**rm 指令**

rm 指令移除【删除】文件或目录

基本语法
```txt
rm  [选项]  要删除的文件或目录
```

常用选项
- -r ：递归删除整个文件夹
- -f ： 强制删除不提示

**演示**
案例 1: 将 /home/aaa.txt  删除
![](attachment/Pasted%20image%2020230912163733.png)

  
案例 2：递归删除整个文件夹 /home/bbb
![](attachment/Pasted%20image%2020230912163829.png)

**使用细节**
强制删除不提示的方法：带上 -f 参数即可

![](attachment/Pasted%20image%2020230912163847.png)

--- 
**mv 指令**

mv 移动文件与目录或重命名

基本语法
```txt
mv oldNameFile newNameFile       (功能描述：重命名) 
mv /temp/movefile /targetFolder  (功能描述：移动文件)
```

**演示**
案例 1: 将 /home/aaa.txt  文件 重新命名为 pig.txt
![](attachment/Pasted%20image%2020230912164005.png)

案例 2:将 /home/pig.txt     文件 移动到 /root 目录下
![](attachment/Pasted%20image%2020230912164035.png)

--- 

**cat 指令**

cat 查看文件内容，是以只读的方式打开。

基本语法
```txt
cat [选项] 要查看的文件
```

常用选项
- -n ：显示行号

**演示**
案例 1:  /etc/profile    文件内容，并显示行号
![](attachment/Pasted%20image%2020230912164150.png)

• 使用细节
cat 只能浏览文件，而不能修改文件，为了浏览方便，一般会带上
`管道命令 | more cat 文件名 | more [分页浏览]`

---

**more 指令**

more 指令是一个基于VI 编辑器的文本过滤器，**它以全屏幕的方式按页显示文本文件的内容**。more 指令中内置了若干快捷键，详见操作说明

基本语法
```txt
more 要查看的文件
```

演示
案例: 采用 more 查看文件
![](attachment/Pasted%20image%2020230912164446.png)

快捷键栏
| 操作   | 功能说明                             |
| ------ | ------------------------------------ |
| 空白键 | 代表向下翻一页                       |
| Enter  | 代表向下翻一行                       |
| q      | 代表立刻离开more，不再显示该文件内容 |
| Ctrl+F | 向下滚动一屏                         |
| Ctrl+B | 返回上一屏                           |
| =      | 输出当前行的行号                     |
| 冒号:+f     | 输出文件名和当前行的行号                                     |

---

**less 指令**

less 指令用来分屏查看文件内容，它的功能与more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，**对于显示大型文件具有较高的效率**。

基本语法
```txt
less 要查看的文件
```


演示
案例: 采用 less 查看一个大文件文件 `/opt/金庸-射雕英雄传 txt 精校版.txt`
![](attachment/Pasted%20image%2020230912164652.png)

快捷键
| 操作     | 功能说明                                     |
| -------- | -------------------------------------------- |
| 空白键   | 向下翻的一页                                 |
| PageDown | 向下翻动一页                                 |
| PageUP   | 向上翻动一页                                 |
| /字符    | 向下搜寻字串的功能。n：向下查找，N：向上查找 |
| ?字串    | 向上搜寻字串的功能。n：向上查找，N：向下查找 |
| q        | 离开less这个程序                                             |

---

**> 指令 和 >>  指令**

\> 指令 和 >> 指`
- \> 输出重定向 : 会将原来的文件的内容覆盖
- \>> 追加： 不会覆盖原来文件的内容，而是追加到文件的尾部。

基本语法
```txt
ls -l > 文件  （功能描述：列表的内容写入文件 a.txt 中（覆盖写））
```

![](attachment/Pasted%20image%2020230913005914.png)

说明：ls -l > a.txt , 将 ls -l 的显示的内容覆盖写入到 a.txt 文件，如果该文件不存在，就创建该文件。

```txt
ls -al >>文件       （功能描述：列表的内容追加到文件 aa.txt 的末尾）
```

![](attachment/Pasted%20image%2020230912165016.png)

```txt
cat 文件 1 > 文件 2 （功能描述：将文件 1 的内容覆盖到文件 2）
```
![](attachment/Pasted%20image%2020230912165053.png)

```txt
echo "内容" >> 文件
```

**演示**
案例 1：将 /home 目录下的文件列表 写入到 /home/info.txt  中
![](attachment/Pasted%20image%2020230912165233.png)

案例 2：将当前日历信息 追加到  /home/mycal 文件中
![](attachment/Pasted%20image%2020230912165305.png)

--- 

**echo 指令**

echo 输出内容到控制台。

基本语法
```txt
echo [选项] [输出内容]
```

**演示**
案例: 使用 echo 指令输出环境变量,输出当前的环境路径
![](attachment/Pasted%20image%2020230912165536.png)

案例: 使用 echo 指令输出 hello,world!
![](attachment/Pasted%20image%2020230912165710.png)

---

**head 指令**

head 用于显示文件的开头部分内容，默认情况下 head 指令显示文件的前 10 行内容

基本语法
```txt
head  文件 (功能描述：查看文件头 10 行内容)
head -n 5 文件  (功能描述：查看文件头 5 行内容，5 可以是任意行数)
```

演示
案例：查看/etc/profile 的前面 5 行代码
![](attachment/Pasted%20image%2020230912165830.png)

--- 

**tail 指令**

tail 用于输出文件中尾部的内容，默认情况下 tail 指令显示文件的后 10 行内容。
基本语法

```txt
tail  文件        （功能描述：查看文件后 10 行内容）
tail  -n 5 文件   （功能描述：查看文件后 5 行内容，5 可以是任意行数）
tail  -f    文件  （功能描述：实时追踪该文档的所有更新，工作经常使用）
```

**演示**
案例 1：查看/etc/profile 最后 5 行的代码
![](attachment/Pasted%20image%2020230912170106.png)

案例 2：实时监控 mydate.txt ,  看看到文件有变化时，是否看到， 实时的追加日期
![](attachment/Pasted%20image%2020230912170149.png)

--- 

**ln 指令**
软链接也叫符号链接，类似于 windows 里的快捷方式，主要存放了链接其他文件的路径

基本语法
```txt
ln -s [原文件或目录] [软链接名] （功能描述：给原文件创建一个软链接）
```

演示
案例 1：在/home 目录下创建一个软连接 linkToRoot，连接到 /root  目录
![](attachment/Pasted%20image%2020230912170343.png)

案例 2：删除软连接 linkToRoot
![](attachment/Pasted%20image%2020230912170403.png)

**细节说明**
当我们使用 pwd 指令查看目录时，仍然看到的是软链接所在目录。

--- 

**history 指令**

查看已经执行过历史命令,也可以执行历史指令

基本语法
```txt
history   （功能描述：查看已经执行过历史命令）
```

演示
案例 1: 显示所有的历史命令
![](attachment/Pasted%20image%2020230912170519.png)

案例 2: 显示最近使用过的 10 个指令。
![](attachment/Pasted%20image%2020230912170530.png)

案例 3：执行历史编号为 178 的指令
![](attachment/Pasted%20image%2020230912170626.png)

## 时间日期类

**date 指令**

显示当前日期

基本语法
```txt
date         （功能描述：显示当前时间）
date +%Y     （功能描述：显示当前年份）
date +%m     （功能描述：显示当前月份）
date +%d     （功能描述：显示当前是哪一天）
date "+%Y-%m-%d %H:%M:%S"（功能描述：显示年月日时分秒）
```

• 演示
案例 1：显示当前时间信息
![](attachment/Pasted%20image%2020230912170927.png)

案例 2：显示当前时间年月日
![](attachment/Pasted%20image%2020230912170937.png)

案例 3：显示当前时间年月日时分秒
![](attachment/Pasted%20image%2020230912170949.png)

**设置日期**

基础语法
```txt
date -s 字符串时间
```

演示
案例 1: 设置系统当前时间 ， 比如设置成 `2018-10-10 11:22:22`
![](attachment/Pasted%20image%2020230912190238.png)

---

**cal 指令**

查看日历指令

基本语法
```txt
cal [选项] （功能描述：不加选项，显示本月日历）
```

演示
案例 1: 显示当前日历
![](attachment/Pasted%20image%2020230912190322.png)

案例 2: 显示 2020 年日历
![](attachment/Pasted%20image%2020230912190341.png)

##  搜索查找类

**find 指令**

find 指令将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端。

基本语法
```txt
find    [搜索范围]    [选项]
```

**选项说明**
| 选项            | 功能                             |
| --------------- | -------------------------------- |
| -name<查询方式> | 按照指定的文件名查找模式查找文件 |
| -user<用户名>   | 查找属于指定用户名所有文件       |
| -size<文件大小  | 按照指定的文件大小查找文件       |
|                 |                                  |

**演示**
案例 1：按文件名：根据名称查找/home 目录下的 hello.txt 文件
![](attachment/Pasted%20image%2020230912190517.png)

案例 2：按拥有者：查找/opt 目录下，用户名称为 nobody 的文件
![](attachment/Pasted%20image%2020230912190539.png)

案例 3：查找整个 linux 系统下大于 20m 的文件（+n 大于 -n 小于 n 等于）
![](attachment/Pasted%20image%2020230912190607.png)


![](attachment/Pasted%20image%2020230912190615.png)

![](attachment/Pasted%20image%2020230912190623.png)

1m = 1024k
![](attachment/Pasted%20image%2020230912190813.png)

查询  / 目录下，所有 .txt 的文件
![](attachment/Pasted%20image%2020230912190825.png)

---

**locate 指令**

locaate 指令可以快速定位文件路径。locate 指令利用事先建立的系统中所有文件名称及路径的locate 数据库实现快速定位给定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻。

基本语法
```txt
locate 搜索文件
```

**特别说明**
由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。

**演示**
案例 1: 请使用 locate 指令快速定位 hello.txt 文件所在目录
![](attachment/Pasted%20image%2020230912190950.png)

---

**grep 指令和 管道符号 |**

grep 过滤查找 ， 管道符，`|`，表示将前一个命令的处理结果输出传递给后面的命令处理。

基本语法
```txt
grep [选项] 查找内容 源文件
```

**常用选项**
| 选项 | 功能             |
| ---- | ---------------- |
| -n   | 显示匹配行及行号 |
| -i   | 忽略字母大小写                 |

演示
案例 1: 请在 hello.txt  文件中，查找 "yes"    所在行，并且显示行号
![](attachment/Pasted%20image%2020230912191117.png)

## 压缩和解压类

**gzip/gunzip 指令**

gzip 用于压缩文件， gunzip  用于解压的

基本语法
```txt
gzip 文件   （功能描述：压缩文件，只能将文件压缩为*.gz 文件）

gunzip 文件.gz   （功能描述：解压缩文件命令）
```

演示
案例 1: gzip 压缩， 将 /home 下的 hello.txt 文件进行压缩
![](attachment/Pasted%20image%2020230912191250.png)

案例 2: gunzip 压缩， 将 /home 下的 hello.txt.gz 文件进行解压缩
![](attachment/Pasted%20image%2020230912191303.png)

细节说明
当我们使用 gzip  对文件进行压缩后，不会保留原来的文件。

--- 

**zip/unzip 指令**

zip 用于压缩文件， unzip 用于解压的，这个在项目打包发布中很有用的

基本语法
```txt
zip    [选项] XXX.zip    将要压缩的内容（功能描述：压缩文件和目录的命令）
unzip  [选项] XXX.zip （功能描述：解压缩文件）
```

zip 常用选项
- -r：递归压缩，即压缩目录

unzip 的常用选项
- -d<目录> ：指定解压后文件的存放目录

演示
案例 1:     将 /home 下的 所有文件进行压缩成 mypackage.zip
![](attachment/Pasted%20image%2020230912191432.png)

![](attachment/Pasted%20image%2020230912191440.png)

案例 2:    将 mypackge.zip 解压到 /opt/tmp 目录下
![](attachment/Pasted%20image%2020230912191455.png)

---
**tar 指令**

tar 指令 **是打包指令**，最后打包后的文件是 .tar.gz 的文件。

基本语法

```txt
tar    [选项]    XXX.tar.gz   打包的内容   
(功能描述：打包目录，压缩后的文件格式.tar.gz)
```

选项说明
| 选项 | 功能               |
| ---- | ------------------ |
| -c   | 产生.tar打包文件   |
| -v   | 显示详细信息       |
| -f   | 指定压缩后的文件名 |
| -z   | 打包同时压缩       |
| -x   | 解压.tar文件       |

**演示**
案例 1：压缩多个文件，将 `/home/a1.txt 和 /home/a2.txt`  压缩成`a.tar.gz`
![](attachment/Pasted%20image%2020230912191647.png)

案例 2：将/home 的文件夹 压缩成 myhome.tar.gz
![](attachment/Pasted%20image%2020230912191658.png)

案例 3：将 a.tar.gz 解压到当前目录
![](attachment/Pasted%20image%2020230912191707.png)

案例 4：将 myhome.tar.gz  解压到 /opt/ 目录下
![](attachment/Pasted%20image%2020230912191717.png)

指定解压到的那个目录，事先要存在才能成功，否则会报错。

# 组管理和权限管理
## Linux 组基本介绍

在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。
- 所有者
- 所在组
- 其它组
- 改变用户所在的组
![](attachment/Pasted%20image%2020230912191950.png)

###  文件/目录 所有者

一般为文件的创建者,谁创建了该文件，就自然的成为该文件的所有者。

####  查看文件的所有者

指令
```txt
ls  -ahl
```

**演示**
创建一个组 police,再创建一个用户 tom,将 tom 放在 police 组 ,然后使用 tom 来创建一个文件 ok.txt，看看情况如何
![](attachment/Pasted%20image%2020230912192313.png)

![](attachment/Pasted%20image%2020230912192330.png)

#### 修改文件所有者

**基础指令**
```txt
chown 新用户名 文件名  (改变文件的所有者)

chown 新用户名:新组名 文件名  （改变用户的所有者和所有组）
```

常用选项
- -R   如果是目录 则使其下所有子文件或目录递归生效

应用案例
要求：使用 root  创建一个文件 apple.txt ，然后将其所有者修改成 tom
![](attachment/Pasted%20image%2020230912192448.png)

### 组的创建
 
**基本指令**
```txt
groupadd 组名
```

**演示**
创建一个组，monster
创建一个用户 fox  ，并放入到 monster 组中
![](attachment/Pasted%20image%2020230912192659.png)

### 文件/目录 所在组

当某个用户创建了一个文件后，默认这个文件的所在组就是该用户所在的组。

#### 查看文件/目录所在组

**基础指令**
```txt
ls –ahl
```

####  修改文件所在的组

**基本指令**
```txt
chgrp 新组名 文件名
```

演示
用 root 用户创建文件 orange.txt ,看看当前这个文件属于哪个组，然后将这个文件所在组，修改到 police 组。
![](attachment/Pasted%20image%2020230912193046.png)

### 其他组
除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组.

### 改变用户所在组
在添加用户时，可以指定将该用户添加到哪个组中，同样的用 root 的管理权限可以改变某个用户所在的组。

**基础指令**
```txt
usermod –g 组名  用户名

usermod  –d  目录名  用户名  (改变该用户登陆的初始目录。)
```

**演示**
创建一个土匪组（bandit）将 tom  这个用户从原来所在的 police 组，修改到 bandit(土匪) 组
![](attachment/Pasted%20image%2020230912193402.png)

## 权限的基本介绍

`ls -l `中显示的内容如下：

```txt
-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc
```

**0-9 位说明**
1. 第 0 位确定文件类型(d, - , l , c , b)
2. 第 1-3 位确定所有者（该文件的所有者）拥有该文件的权限。→User
3. 第 4-6 位确定所属组（同用户组的）拥有该文件的权限，→Group
4. 第 7-9 位确定其他用户拥有该文件的权限 →Other

![](attachment/Pasted%20image%2020230912193810.png)

### rwx 权限详解
**rwx 作用到文件**
- r 代表可读(read):  可以读取,查看
 - w 代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.
- x 代表可执行(execute):可以被执行

**rwx 作用到目录**
- r 代表可读(read):  可以读取，ls 查看目录内容
- w 代表可写(write):  可以修改,目录内创建+删除+重命名目录
 - x 代表可执行(execute):可以进入该目录

### 文件及目录权限实际案例

`ls -l `中显示的内容如下
```txt
-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc
```

10 个字符确定不同用户能对文件干什么

第一个字符代表文件类型： 文件 (-),目录(d),链接(l)

其余字符每 3 个一组(rwx) 读(r) 写(w) 执行(x) 
- 第一组 rwx : 文件拥有者的权限是读、写和执行
- 第二组 rw- :  与文件拥有者同一组的用户的权限是读、写但不能执行
- 第三组 r-- :     不与文件拥有者同组的其他用户的权限是读不能写和执行
可用数字表示为: r=4,w=2,x=1  因此 rwx=4+2+1=7

| 内容         | 描述                                          |
| ----------- | -------------------------------------------- |
| 1           | 文件：硬连接数或  目录：子目录数             |
| root        | 用户                                         |
| root        | 组                                           |
| 1213        | 文件大小(字节)，如果是文件夹，显示 4096 字节 |
| Feb 2 09:39 | Feb 2 09:39                                  |
| abc         | 文件名                                             |



### 修改权限

**基本说明**
通过 chmod 指令，可以修改文件或者目录的权限

#### + 、-、=  变更权限
- u：文件拥有者  
- g：与文件拥有者同一组的用户  
- o：不与文件拥有者同组  
- a：所有人(u、g、o 的总和)
```txt
chmod  u=rwx,g=rx,o=x      文件目录名
chmod  o+w        文件目录名
chmod  a-x        文件目录名
```

案例演示
给 abc 文件 的所有者读写执行的权限，给所在组读执行权限，**给其它组读执行权限**。
![](attachment/Pasted%20image%2020230912195548.png)

给abc 文件的所有者除去执行的权限，增加组写的权限
![](attachment/Pasted%20image%2020230912195614.png)

给 abc 文件的所有用户添加读的权限
![](attachment/Pasted%20image%2020230912195719.png)


#### 通过数字变更权限
规则：r=4 w=2 x=1 ,rwx=4+2+1=7 
`chmod u=rwx,g=rx,o=x 文件目录名`
相当于 
```txt
chmod 751 文件目录名
```

案例演示
要求：将 /home/abc.txt 文件的权限修改成  rwxr-xr-x, 使用给数字的方式实现：
- rwx = 4+2+1 = 7
- r-x = 4+1=5
- r-x = 4+1 =5

指令：`chmod 755 /home/abc.txt`

# crond 任务调度
原理示意图
![](attachment/Pasted%20image%2020230912200649.png)
crontab 进行 定时任务的设置，

## 概述

任务调度：是指系统在某个时间执行的特定的命令或程序。

任务调度分类
1. 系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等
2. 个别用户工作：个别用户可能希望执行某些程序，比如对 MySQL 数据库的备份。

**基础语法**
```txt
crontab [选项]
```

常用选项
![](attachment/Pasted%20image%2020230912214638.png)

## 快速入门

**任务的要求**
设置任务调度文件：`/etc/crontab`
设置个人任务调度。执行 `crontab –e` 命令。接着输入任务到调度文件

如：`*/1 * * * * ls  –l   /etc/ > /tmp/to.txt`

意思说每小时的每分钟执行 `ls –l /etc/ > /tmp/to.tx`t 命令

**步骤如下**
1. cron -e
2. `*/ 1 * * * * ls -l /etc >> /tmp/to.txt`
3. 当保存退出后就程开始。
4. 在每一分钟都会自动的调用 `ls -l /etc >> /tmp/to.txt`

**参数细节说明**

![](attachment/Pasted%20image%2020230912215015.png)

![](attachment/Pasted%20image%2020230912215019.png)

## 任务调度的几个演示
案例 1：每隔 1 分钟，就将当前的日期信息，追加到 /tmp/mydate 文件中

先编写一个文件  
```txt
touch /home/mytask1.sh
date >> /tmp/mydate
```

给 mytask1.sh  一个可以执行权限
```txt
chmod 744 /home/mytask1.sh
```

设置个人调度
```txt
crontab -e
*/1 * * * *    /home/mytask1.sh
```

成功

---

案例 2：每隔 1 分钟， 将当前日期和日历都追加到 /home/mycal 文件中

先编写一个文件
```txt
touch /home/mytask2.sh

文件内容
date >> /tmp/mycal 
cal >> /tmp/mycal

```

给 mytask1.sh 一个可以执行权限
```txt
chomd 744 /home/mytask2.sh
```



成功

---

案例 3:  每天凌晨 2:00 将mysql 数据库 testdb  ，备份到文件中mydb.bak

先编写一个文件  
```touch
/home/mytask3.sh

文件内容
/usr/local/mysql/bin/mysqldump -u root -proot testdb > /tmp/mydb.bak
```



给 mytask3.sh 一个可以执行权限
```txt
chmod 744 /home/mytask3.sh
```

设置个人调度
```txt
crontab -e
0 2 * * *    /home/mytask3.sh
```

成功

## crond 相关指令
- conrtab –r：终止任务调度。
- crontab –l：列出当前有那些任务调度
- service crond restart  重启任务调度

# Linux 磁盘分区、挂载
## 分区基础知识
磁盘分区是将硬盘划分为不同的逻辑部分的过程。每个分区可以被视为一个独立的磁盘，它具有自己的文件系统，并可以存储数据和文件。

**分区的方式**
MBR 分区
1. 最多支持四个主分区
2. 系统只能安装在主分区
3. 扩展分区要占一个主分区
4. MBR 最大只支持 2TB，但拥有最好的兼容性

GTP 分区
1. 支持无限多个主分区（但操作系统可能限制，比如 windows 下最多 128 个分区）
2. 最大支持 18EB 的大容量（1EB=1024 PB，1PB=1024 TB  ）
3. windows7 64 位以后支持 gtp

**windows 下的磁盘分区**
Windows的磁盘分区原理是基于磁盘分区表（Partition Table）来管理磁盘的分区。分区表存储在硬盘的第一个扇区，通常称为主引导记录（Master Boot Record，MBR）或GUID分区表（GUID Partition Table，GPT）。磁盘分区表记录了硬盘上所有分区的位置和大小，使操作系统能够正确地识别和访问这些分区。

在Windows中，常用的分区工具有磁盘管理器（Disk Management）和命令行工具DiskPart。这些工具提供了创建、删除、调整和格式化分区的功能。

Windows支持两种主要的分区类型：主分区和扩展分区。主分区是可以直接被操作系统引导的分区，而扩展分区则可以容纳多个逻辑分区。一个硬盘最多可以有四个主分区或三个主分区加一个扩展分区。

每个分区都可以分配一个驱动器号或挂载点，以便操作系统可以访问和管理分区中的文件和数据。分区可以被格式化为不同的文件系统，如FAT32、NTFS等，不同的文件系统会影响文件存储的方式和限制。

磁盘分区的好处是可以更好地组织数据，提高存储空间的利用率，同时可以方便地对不同的分区进行备份和恢复。此外，磁盘分区还可以提高系统的性能，因为操作系统可以更好地管理和访问不同的分区。

![](attachment/Pasted%20image%2020230912231437.png)

**Linux 分区**
**原理介绍**
Linux 来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 , Linux 中每个分区都是用来组成整个文件系统的一部分。

Linux 采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录， 且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。

示意图
![](attachment/Pasted%20image%2020230912231725.png)


**硬盘说明**
Linux 硬盘分 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘

对于 IDE 硬盘，驱动器标识符为“hdx~”,其中“hd”表明分区所在设备的类型，这里是指 IDE 硬盘了。“x”为盘号（a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘）,“~”代表分区， 前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。例，hda3 表示为第一个IDE 硬盘上的第三个主分区或扩展分区,hdb2 表示为第二个IDE 硬盘上的第二个主分区或扩展分区。

对于 SCSI 硬盘则标识为“sdx~”，SCSI 硬盘是用“sd”来表示分区所在设备的类型的，其余则和 IDE 硬盘的表示方法一样。

**使用lsblk 指令查看当前系统的分区情况**
![](attachment/Pasted%20image%2020230912232706.png)

![](attachment/Pasted%20image%2020230912232709.png)



## 如何增加一块硬盘

挂载的经典案例
需求是给我们的 Linux 系统增加一个新的硬盘，并且挂载到/home/newdisk

虚拟机添加硬盘

分区    
```txt
fdisk /dev/sdb
```

格式化  
```txt
mkfs -t ext4  /dev/sdb1
```

挂载   
先创建一个被挂载的目录
```txt
/home/newdisk
```
挂载 
```txt
mount /dev/sdb1 /home/newdisk
```

设置可以自动挂载(永久挂载，当你重启系统，仍然可以挂载到 /home/newdisk) 。

```txt
vim  /etc/fstab

文件内容
/dev/sdb1  /home/newdisk   ext4   defaults   0 0
```

**具体的操作步骤整理**

**虚拟机增加硬盘步骤 1**
![](attachment/Pasted%20image%2020230912233835.png)
在【虚拟机】菜单中，选择【设置】，然后设备列表里添加硬盘，然后一路【下一步】，中间只有选择磁盘大小的地方需要修改，至到完成。然后重启系统（才能识别）

---

**虚拟机增加硬盘步骤 2**

分区命令  
```txt
fdisk  /dev/sdb
```

开始对/sdb 分区
- m    显示命令列表
- p     显示磁盘分区 同 fdisk    –l
- n     新增分区
- d     删除分区
- w    写入并退出
说明： 开始分区后输入 n，新增分区，然后选择 p ，分区类型为主分区。两次回车默认剩余全部空间。最后输入 w 写入分区并退出，若不保存退出输入 q。
![](attachment/Pasted%20image%2020230912234009.png)

---

**虚拟机增加硬盘步骤 3**
格式化磁盘
分区命令
```txt
mkfs -t ext4 /dev/sdb1
```
其中 ext4 是分区类型

---

**虚拟机增加硬盘步骤 4**

挂载
将一个分区与一个目录联系起来，

```txt
mount 设备名称 挂载目录
```

例如
```txt
mount /dev/sdb1 /newdisk
```

卸载分区
```txt
umount   设备名称 或者   挂载目录
```

例如  
```txt
umount /dev/sdb1 
umount /newdisk
```

---

**虚拟机增加硬盘步骤 5**

永久挂载:  通过修改`/etc/fstab` 实现挂载添加完成后 执行 `mount –a` 即刻生效

![](attachment/Pasted%20image%2020230912234440.png)

## 磁盘情况查询
### 查询系统整体磁盘使用情况

基本语法
```txt
df -h
```

演示
查询系统整体磁盘使用情况
![](attachment/Pasted%20image%2020230912234917.png)

### 查询指定目录的磁盘占用情况

基本语法
```txt
du -h    /目录
```

查询指定目录的磁盘占用情况，默认为当前目录
- -s 指定目录占用大小汇总
- -h 带计量单位
- -a 含文件
- --max-depth=1    子目录深度
- -c 列出明细的同时，增加汇总值

演示
查询 /opt 目录的磁盘占用情况，深度为 1
![](attachment/Pasted%20image%2020230912235054.png)

### 磁盘情况-工作实用指令
统计/home 文件夹下文件的个数
![](attachment/Pasted%20image%2020230912235319.png)

统计/home 文件夹下目录的个数
![](attachment/Pasted%20image%2020230912235744.png)

统计/home 文件夹下文件的个数，包括子文件夹里的
![](attachment/Pasted%20image%2020230912235758.png)

统计文件夹下目录的个数，包括子文件夹里的
![](attachment/Pasted%20image%2020230912235820.png)

以树状显示目录结构
![](attachment/Pasted%20image%2020230912235841.png)

# 网络配置
## DHCP
![](attachment/Pasted%20image%2020230913145736.png)
缺点: linux 启动后会自动获取 IP,缺点是每次自动获取的 ip 地址可能不一样。这个不适用于做服务器，因为我们的服务器的 ip 需要时固定的。

## 固定的IP

说明
直 接 修 改 配 置 文 件 来 指 定 IP, 并 可 以 连 接 到 外 网 ( 程 序 员 推 荐 ) ， 编 辑                                 
```txt
vi /etc/sysconfig/network-scripts/ifcfg-eth0
```

要求：将 ip 地址配置的静态的，ip 地址为 192.168.184.130
![](attachment/Pasted%20image%2020230913145830.png)

修改后，一定要 重启服务
1. service network restart
2. reboot （重启系统）

![](attachment/Pasted%20image%2020230913145911.png)

# 进程管理

## 进程的基本介绍

在 LINUX 中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个 ID 号。

每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程。例如 www 服务器。

每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。

一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。

## 显示系统执行的进程

查看进行使用的指令是 `ps` ,一般来说使用的参数是 `ps -aux`
![](attachment/Pasted%20image%2020230913150224.png)
![](attachment/Pasted%20image%2020230913150245.png)

**ps 指令详解**
指令
```txt
ps –aux|grep xxx 
```
比如我看看有没有 sshd 服务

指令说明

- System V 展示风格
- USER：用户名称
- PID：进程号
- %CPU：进程占用 CPU 的百分比
- %MEM：进程占用物理内存的百分比
- VSZ：进程占用的虚拟内存大小（单位：KB）
- RSS：进程占用的物理内存大小（单位：KB）
- TT：终端名称,缩写 .
- STAT：进程状态，其中 S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等
- STARTED：进程的启动时间
- TIME：CPU 时间，即进程使用 CPU 的总时间
- COMMAND：启动进程所用的命令和参数，如果过长会被截断显示

**应用实例**
要求：以全格式显示当前所有的进程，查看进程的父进程。
![](attachment/Pasted%20image%2020230913150652.png)

- ps -ef 是以全格式显示当前所有的进程
- -e 显示所有进程。-f 全格式。
- ps -ef | grep xxx
- 是 BSD 风格
- UID：用户 ID
- PID：进程 ID
- PPID：父进程 ID
- C：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高
- STIME：进程启动的时间
- TTY：完整的终端名称
- TIME：CPU 时间
- CMD：启动进程所用的命令和参数

思考题，如果我们希望查看 sshd 进程的父进程号是多少，应该怎样查询 ？
![](attachment/Pasted%20image%2020230913150918.png)

## 终止进程kill 和 killall

介绍
进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用 kill 命令来完成此项任务。

基本语法
```txt
kill  [选项] 进程号（功能描述：通过进程号杀死进程）
```

```txt
killall 进程名称
（功能描述：通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用）
```

常用选项
- -9 :表示强迫进程立即停止

**最佳实践**
案例 1：踢掉某个非法登录用户
![](attachment/Pasted%20image%2020230913151300.png)

案例 2: 终止远程登录服务 sshd, 在适当时候再次重启 sshd 服务
![](attachment/Pasted%20image%2020230913151408.png)

案例 3: 终止多个 gedit  编辑器 【killall ,  通过进程名称来终止进程】
![](attachment/Pasted%20image%2020230913151450.png)

案例 4：强制杀掉一个终端
![](attachment/Pasted%20image%2020230913151502.png)

## 查看进程树 pstree

**基本语法**
```txt
pstree [选项] ,可以更加直观的来看进程信息
```

常用选项
- -p :显示进程的 PID
- -u :显示进程的所属用户

**应用实例**
案例 1：请你树状的形式显示进程的 pid
![](attachment/Pasted%20image%2020230913151749.png)

案例 2：请你树状的形式进程的用户 id 
pstree -u 即可。

## 服务(Service)管理

**介绍**
服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql , sshd 防火墙等)，因此我们又称为守护进程.

原理图
![](attachment/Pasted%20image%2020230913152010.png)

service 管理指令
```txt
service    服务名 [start|stop|restart|reload|status]

```
在 CentOS7.0 后 不再使用 service ,而是 systemctl

**使用案例**
查看当前防火墙的状况，关闭防火墙和重启防火墙。
![](attachment/Pasted%20image%2020230913152940.png)

![](attachment/Pasted%20image%2020230913152945.png)

细节讨论
关闭或者启用防火墙后，立即生效。telnet 测试 某个端口即可
![](attachment/Pasted%20image%2020230913153023.png)

**查看服务名**
方式 1：使用 setup -> 系统服务 就可以看到。
![](attachment/Pasted%20image%2020230913153106.png)

方式 2：`/etc/init.d/服务名称`
![](attachment/Pasted%20image%2020230913153139.png)

---

**服务的运行级别(runlevel):**
查看或者修改默认级别：  vi /etc/inittab
Linux 系统有 7 种运行级别(runlevel)：常用的是级别 3 和 5
- 运行级别 0：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动
- 运行级别 1：单用户工作状态，root 权限，用于系统维护，禁止远程登陆
- 运行级别 2：多用户状态(没有 NFS)，不支持网络
- 运行级别 3：完全的多用户状态(有 NFS)，登陆后进入控制台命令行模式
- 运行级别 4：系统未使用，保留
- 运行级别 5：X11 控制台，登陆后进入图形 GUI 模式
- 运行级别 6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动

---

**开机的流程说明**
![](attachment/Pasted%20image%2020230913153246.png)

**chkconfig 指令介绍**

通过chkconfig 命令可以给每个服务的各个运行级别设置自启动/关闭基本语法

查看服务
```txt
chkconfig --list | grep xxx
```

![](attachment/Pasted%20image%2020230913153324.png)

![](attachment/Pasted%20image%2020230913153345.png)

查看某个服务
```txt
chkconfig  服务名 --list
```

![](attachment/Pasted%20image%2020230913153333.png)


请将 sshd 服务在运行级别为  5 的情况下，不要自启动。
```txt
chkconfig --level 5 服务名 on/off
```

![](attachment/Pasted%20image%2020230913153422.png)


**应用实例**

案例 1： 请显示当前系统所有服务的各个运行级别的运行状态
```txt
chkconfig --list
```

案例 2 ：请查看 sshd 服务的运行状态
```txt
service sshd status
```

案例 3： 将 sshd 服务在运行级别 5 下设置为不自动启动，看看有什么效果？
```txt
chkconfig --level 5 sshd off
```

案例 4： 当运行级别为 5 时，关闭防火墙。
```txt
chkconfig --level 5 iptables off
```

案例 5： 在所有运行级别下，关闭防火墙
```txt
chkconfig    iptables off
```

案例 6： 在所有运行级别下，开启防火墙
```txxt
chkconfig    iptables    on
```

使用细节
chkconfig 重新设置服务后自启动或关闭，需要重启机器 reboot 才能生效

## 动态监控进程

介绍
top 与 ps 命令很相似。它们都用来显示正在执行的进程。Top 与 ps 最大的不同之处，在于 top **在执行一段时间可以更新正在运行的的进程**。

**基本语法**
```txt
top [选项]
```

选项说明
![](attachment/Pasted%20image%2020230913154038.png)

![](attachment/Pasted%20image%2020230913154042.png)

应用实例
案例 1：监视特定用户
top：输入此命令，按回车键，查看执行的进程。
u：然后输入“u”回车，再输入用户名，即可

![](attachment/Pasted%20image%2020230913154128.png)

案例 2：终止指定的进程。
top：输入此命令，按回车键，查看执行的进程。
k：然后输入“k”回车，再输入要结束的进程 ID 号
![](attachment/Pasted%20image%2020230913154239.png)

案例 3:指定系统状态更新的时间(每隔 10 秒自动更新， 默认是 3 秒)：
```txt
top -d 10
```

## 查看系统网络情况netstat

基本语法
```txt
netstat [选项] netstat -anp
```

选项说明
- -an  按一定顺序排列输出
- -p  显示哪个进程在调用

应用案例
查看系统所有的网络服务
![](attachment/Pasted%20image%2020230913154509.png)

请查看服务名为 sshd 的服务的信息。
![](attachment/Pasted%20image%2020230913154527.png)

# Shell 编程
## Shell 是什么
![](attachment/Pasted%20image%2020230913154948.png)

Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序.

## Shell 脚本的执行方式

脚本格式要求
1. 脚本以`#!/bin/bash` 开头
2. 脚本需要有可执行权限

编写第一个Shell 脚本
需求说明
创建一个 Shell 脚本，输出 hello world!

```shell
#!/bin/bash
echo "hello,world"
```

脚本的常用执行方式
方式 1：输入脚本的**绝对路径**或**相对路径**
- 首先要赋予 helloworld.sh  脚本的+x 权限
- 执行脚本
![](attachment/Pasted%20image%2020230913155517.png)

方式 2(sh+脚本)，不推荐
说明：不用赋予脚本+x 权限，直接执行即可
![](attachment/Pasted%20image%2020230913155539.png)

## shell 变量

**Shell 的变量的介绍**

Linux Shell 中的变量分为，**系统变量**和**用户自定义变量**。
- 系统变量：`$HOME、$PWD、$SHELL、$USER `等等，比如: `echo $HOME` 等等..
![](attachment/Pasted%20image%2020230913155907.png)

- 显示当前 shell 中所有变量：set


 **shell 变量的定义**
基本语法
- 定义变量：`变量=值 `
- 撤销变量：`unset 变量`
- 声明静态变量：`readonly 变量`，注意：不能 `unset`

快速入门
案例 1：定义变量 A
案例 2：撤销变量 A
![](attachment/Pasted%20image%2020230913160053.png)

案例 3：声明静态的变量 B=2，不能 unset
![](attachment/Pasted%20image%2020230913160126.png)

案例 4：可把变量提升为全局环境变量，可供其他 shell 程序使用

**定义变量的规则**
- 变量名称可以由字母、数字和下划线组成，但是不能以数字开头。
- 等号两侧不能有空格
- 变量名称一般习惯为大写

**将命令的返回值赋给变量（重点）**
- A=\`ls -la\` 反引号，运行里面的命令，并把结果返回给变量 A
- A=$(ls -la) 等价于反引号

![](attachment/Pasted%20image%2020230913160442.png)

---

**设置环境变量**

基本语法
```txt
export 变量名=变量值 （功能描述：将 shell 变量输出为环境变量）
source  配置文件     （功能描述：让修改后的配置信息立即生效）
echo $变量名         （功能描述：查询环境变量的值）
```
![](attachment/Pasted%20image%2020230913161012.png)

**快速入门**

在/etc/profile 文件中定义 TOMCAT_HOME 环境变量
![](attachment/Pasted%20image%2020230913161050.png)

查看环境变量 TOMCAT_HOME 的值
```txt
echo $TOMCAT_HOME
```

在另外一个 shell 程序中使用 TOMCAT_HOME
![](attachment/Pasted%20image%2020230913161130.png)

注意：在输出 TOMCAT_HOME 环境变量前，需要让其生效
```txt
source /etc/profile
```

## 位置参数变量

**介绍**
当我们执行一个 shell 脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量，比如 ：` ./myshell.sh 100 200 `,  这个就是一个执行 shell 的命令行，可以在 `myshell`  脚本中获取到参数信息

基本语法
- `$n `（功能描述：n 为数字，$0 代表命令本身，`$1-$9` 代表第一到第九个参数，十以上的参数，十以上的参数需要用大括号包含，如`${10}`）
- `$*` （功能描述：这个变量代表命令行中所有的参数，`$*`把所有的参数看成一个整体）
- `$@`（功能描述：这个变量也代表命令行中所有的参数，不过`$@`把每个参数区分对待）
- `$#`（功能描述：这个变量代表命令行中所有参数的个数）

**位置参数变量应用实例**
案例：编写一个 shell 脚本`positionPara.sh` ， 在脚本中获取到命令行的各个参数信息

![](attachment/Pasted%20image%2020230913161544.png)

![](attachment/Pasted%20image%2020230913161549.png)

